<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FluidNC Probe Utility v1.13.3</title>
<style>
:root {
  --bg-primary: #1a1a1a;
  --bg-secondary: #252525;
  --bg-tertiary: #2d2d2d;
  --bg-input: #333;
  --text-primary: #e0e0e0;
  --text-secondary: #999;
  --text-muted: #666;
  --accent: #4a9eff;
  --accent-hover: #6bb3ff;
  --success: #4caf50;
  --warning: #ff9800;
  --danger: #f44336;
  --border: #444;
  --border-light: #555;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-size: 14px;
  line-height: 1.4;
  min-height: 100vh;
}
#app-container { display: flex; flex-direction: column; min-height: 100vh; }
#header {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}
.header-group { display: flex; align-items: center; gap: 8px; }
.header-label { color: var(--text-secondary); font-size: 12px; }
#header input[type="text"], #header input[type="number"] {
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 13px;
}
#ip-input { width: 120px; }
#port-input { width: 60px; }
button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  transition: all 0.15s ease;
}
button:hover:not(:disabled) { background: var(--border); }
button:disabled { opacity: 0.5; cursor: not-allowed; }
button.btn-primary { background: var(--accent); border-color: var(--accent); color: #fff; }
button.btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
button.btn-danger { background: var(--danger); border-color: var(--danger); color: #fff; }
button.btn-success { background: var(--success); border-color: var(--success); color: #fff; }
#stop-btn { font-weight: bold; padding: 6px 16px; font-size: 14px; }
.status-indicator { display: flex; align-items: center; gap: 6px; font-size: 13px; }
.status-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--danger); }
.status-dot.connected { background: var(--success); }
#tab-nav {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  display: flex;
  padding: 0 16px;
  overflow-x: auto;
}
.tab-btn {
  background: transparent;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--text-secondary);
  padding: 10px 16px;
  font-size: 13px;
  border-radius: 0;
}
.tab-btn:hover { color: var(--text-primary); background: var(--bg-tertiary); }
.tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }
#tab-content { flex: 1; padding: 16px; overflow-y: auto; }
.tab-panel { display: none; }
.tab-panel.active { display: block; }
#status-bar {
  background: var(--bg-secondary);
  border-top: 1px solid var(--border);
  padding: 6px 16px;
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: var(--text-secondary);
}
.alarm-status { color: var(--success); }
.alarm-status.alarm { color: var(--danger); font-weight: bold; }
.section {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 16px;
  margin-bottom: 16px;
}
.section-title { font-size: 14px; font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
.form-row { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
.form-label { color: var(--text-secondary); font-size: 13px; min-width: 140px; }
input[type="text"], input[type="number"], select, textarea {
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 13px;
}
input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); }
input[type="number"] { width: 80px; }
textarea { resize: vertical; min-height: 100px; width: 100%; font-family: monospace; }
.input-with-unit { display: flex; align-items: center; gap: 6px; }
.unit-suffix { color: var(--text-muted); font-size: 12px; }
.text-muted { color: var(--text-muted); }
.text-success { color: var(--success); }
.text-danger { color: var(--danger); }
.mt-1 { margin-top: 8px; }
.control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; }
.position-table { width: 100%; border-collapse: collapse; }
.position-table th, .position-table td { padding: 8px 12px; text-align: right; border-bottom: 1px solid var(--border); }
.position-table th { text-align: left; color: var(--text-secondary); font-weight: normal; font-size: 12px; }
.position-table .axis-label { font-weight: 600; text-align: left; width: 40px; }
.position-table .coord-value { font-family: monospace; font-size: 15px; min-width: 100px; }
.position-table .actions { text-align: center; white-space: nowrap; }
.position-table .actions button { padding: 4px 8px; font-size: 12px; margin: 0 2px; }
.jog-container { display: flex; gap: 24px; justify-content: center; }
.jog-xy { display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px); gap: 4px; }
.jog-z { display: grid; grid-template-columns: 50px; grid-template-rows: repeat(2, 50px); gap: 4px; }
.jog-btn { width: 50px; height: 50px; font-size: 20px; display: flex; align-items: center; justify-content: center; padding: 0; }
.jog-btn:active { background: var(--accent); }
.jog-placeholder { width: 50px; height: 50px; }
.jog-label { text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 4px; }
.home-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
.home-buttons button { min-width: 80px; }
.output-row { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
.output-row .output-name { min-width: 80px; color: var(--text-secondary); }
.output-row button { min-width: 60px; }
.output-row button.active { background: var(--success); border-color: var(--success); }
.probe-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
@media (max-width: 800px) { .probe-layout { grid-template-columns: 1fr; } }
.probe-params .form-label { min-width: 130px; }
.probe-params input[type="number"] { width: 90px; }
.probe-params input[type="text"] { width: 180px; }
.preset-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
.preset-row select { min-width: 150px; flex: 1; }
.preset-row button { padding: 5px 10px; font-size: 12px; }
.results-grid { display: grid; grid-template-columns: auto 1fr; gap: 6px 16px; font-size: 13px; }
.results-grid .label { color: var(--text-secondary); }
.results-grid .value { font-family: monospace; }
.results-actions { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }
.probe-status { padding: 10px; border-radius: 4px; margin: 12px 0; font-size: 13px; }
.probe-status.ready { background: rgba(76, 175, 80, 0.15); border: 1px solid var(--success); color: var(--success); }
.probe-status.error { background: rgba(244, 67, 54, 0.15); border: 1px solid var(--danger); color: var(--danger); }
.probe-status.working { background: rgba(255, 152, 0, 0.15); border: 1px solid var(--warning); color: var(--warning); }
.placeholder-content { text-align: center; padding: 60px 20px; color: var(--text-muted); }
.placeholder-content h2 { font-size: 24px; margin-bottom: 12px; color: var(--text-secondary); }
.settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; }
.json-actions { display: flex; gap: 8px; margin-top: 12px; }
.instructions { background: var(--bg-primary); border: 1px solid var(--border); border-left: 3px solid var(--accent); padding: 12px; margin-top: 16px; font-size: 13px; }
</style>
</head>
<body>
<div id="app-container">
<header id="header">
  <div class="header-group">
    <span class="header-label">IP:</span>
    <input type="text" id="ip-input" value="192.168.73.13">
  </div>
  <div class="header-group">
    <span class="header-label">Port:</span>
    <input type="number" id="port-input" value="81">
  </div>
  <button id="connect-btn" class="btn-primary">Connect</button>
  <button id="disconnect-btn" disabled>Disconnect</button>
  <div class="status-indicator">
    <span class="status-dot" id="status-dot"></span>
    <span id="status-text">Disconnected</span>
  </div>
  <div style="flex: 1;"></div>
  <button id="stop-btn" class="btn-danger">⚠ STOP</button>
</header>

<nav id="tab-nav">
  <button class="tab-btn active" data-tab="control">Control</button>
  <button class="tab-btn" data-tab="cylinder">Cylinder Probe</button>
  <button class="tab-btn" data-tab="hole">Hole Probe</button>
  <button class="tab-btn" data-tab="corner">Corner Probe</button>
  <button class="tab-btn" data-tab="side-align">Side Align</button>
  <button class="tab-btn" data-tab="heightmap">Height Map</button>
  <button class="tab-btn" data-tab="settings">Settings</button>
</nav>

<main id="tab-content">

<!-- CONTROL TAB -->
<div class="tab-panel active" id="panel-control">
  <div class="control-grid">
    <div class="section">
      <div class="section-title">Position</div>
      <table class="position-table">
        <thead><tr><th></th><th>MCS</th><th>WCS</th><th>Actions</th></tr></thead>
        <tbody>
          <tr>
            <td class="axis-label">X</td>
            <td class="coord-value" id="pos-mcs-x">0.000</td>
            <td class="coord-value" id="pos-wcs-x">0.000</td>
            <td class="actions">
              <button onclick="zeroAxis('X')">Zero</button>
              <button onclick="gotoZero('X')">Go 0</button>
            </td>
          </tr>
          <tr>
            <td class="axis-label">Y</td>
            <td class="coord-value" id="pos-mcs-y">0.000</td>
            <td class="coord-value" id="pos-wcs-y">0.000</td>
            <td class="actions">
              <button onclick="zeroAxis('Y')">Zero</button>
              <button onclick="gotoZero('Y')">Go 0</button>
            </td>
          </tr>
          <tr>
            <td class="axis-label">Z</td>
            <td class="coord-value" id="pos-mcs-z">0.000</td>
            <td class="coord-value" id="pos-wcs-z">0.000</td>
            <td class="actions">
              <button onclick="zeroAxis('Z')">Zero</button>
              <button onclick="gotoZero('Z')">Go 0</button>
            </td>
          </tr>
        </tbody>
      </table>
      <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
        <button onclick="zeroAxis('XY')" class="btn-primary">Zero XY</button>
        <button onclick="gotoZero('XY')">Go XY 0</button>
        <button onclick="refreshPosition()" style="margin-left: auto;">↻ Refresh</button>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Home</div>
      <div class="home-buttons">
        <button onclick="homeAxis('all')" class="btn-primary">Home All</button>
        <button onclick="homeAxis('X')">Home X</button>
        <button onclick="homeAxis('Y')">Home Y</button>
        <button onclick="homeAxis('Z')">Home Z</button>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Jog</div>
      <div class="jog-container">
        <div>
          <div class="jog-xy">
            <div class="jog-placeholder"></div>
            <button class="jog-btn" data-axis="Y" data-dir="+">▲</button>
            <div class="jog-placeholder"></div>
            <button class="jog-btn" data-axis="X" data-dir="-">◀</button>
            <div class="jog-placeholder"></div>
            <button class="jog-btn" data-axis="X" data-dir="+">▶</button>
            <div class="jog-placeholder"></div>
            <button class="jog-btn" data-axis="Y" data-dir="-">▼</button>
            <div class="jog-placeholder"></div>
          </div>
          <div class="jog-label">XY</div>
        </div>
        <div>
          <div class="jog-z">
            <button class="jog-btn" data-axis="Z" data-dir="+">▲</button>
            <button class="jog-btn" data-axis="Z" data-dir="-">▼</button>
          </div>
          <div class="jog-label">Z</div>
        </div>
      </div>
      <p class="text-muted mt-1" style="text-align: center; font-size: 11px;">Click and hold to jog</p>
    </div>
    <div class="section">
      <div class="section-title">Outputs</div>
      <div class="output-row">
        <span class="output-name">Mist</span>
        <button id="mist-btn" onclick="toggleOutput('mist')">OFF</button>
      </div>
      <div class="output-row">
        <span class="output-name">Vacuum</span>
        <button id="vacuum-btn" onclick="toggleOutput('vacuum')">OFF</button>
      </div>
      <div class="output-row">
        <span class="output-name">IoT PDU</span>
        <button id="iot-btn" onclick="toggleOutput('iot')">OFF</button>
      </div>
    </div>
  </div>
</div>

<!-- CYLINDER PROBE TAB -->
<div class="tab-panel" id="panel-cylinder">
  <div class="probe-layout">
    <div>
      <div class="section">
        <div class="section-title">Presets</div>
        <div class="preset-row">
          <select id="cyl-preset-select"><option value="">-- Select Preset --</option></select>
          <button onclick="loadCylinderPreset()">Load</button>
          <button onclick="saveCylinderPreset()">Save</button>
          <button onclick="deleteCylinderPreset()">Delete</button>
        </div>
      </div>
      <div class="section probe-params">
        <div class="section-title">Parameters</div>
        <div class="form-row">
          <span class="form-label">Preset Name:</span>
          <input type="text" id="cyl-preset-name" placeholder="e.g., 25mm Dowel">
        </div>
        <div class="form-row">
          <span class="form-label">Cylinder Ø:</span>
          <div class="input-with-unit">
            <input type="number" id="cyl-diameter" value="25" min="1" step="0.1" onchange="updateCylProbeDistance()">
            <span class="unit-suffix">mm</span>
          </div>
        </div>
        <div class="form-row">
          <span class="form-label">Probe Distance:</span>
          <div class="input-with-unit">
            <input type="number" id="cyl-probe-distance" value="17.5" min="1" step="0.5">
            <span class="unit-suffix">mm</span>
          </div>
          <span class="text-muted" style="font-size: 11px;">(auto: Ø/2 + 5)</span>
        </div>
        <div class="form-row">
          <span class="form-label">Probe Depth:</span>
          <div class="input-with-unit">
            <input type="number" id="cyl-probe-depth" value="5" min="1" step="0.5">
            <span class="unit-suffix">mm</span>
          </div>
        </div>
        <div class="form-row">
          <span class="form-label">Feedrate:</span>
          <div class="input-with-unit">
            <input type="number" id="cyl-feedrate" value="100" min="10" step="10">
            <span class="unit-suffix">mm/min</span>
          </div>
        </div>
        <div class="form-row">
          <span class="form-label">Probe Tip Ø:</span>
          <div class="input-with-unit">
            <input type="number" id="cyl-tip-dia" value="2.0" readonly disabled>
            <span class="unit-suffix">mm</span>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Actions</div>
        <div id="cyl-probe-status"></div>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button onclick="testProbeConnection('cylinder')" class="btn-primary">Test Probe</button>
          <button onclick="runCylinderProbe()" class="btn-success" id="cyl-run-btn">▶ Run Probe</button>
        </div>
      </div>
    </div>
    <div>
      <div class="section">
        <div class="section-title">Results</div>
        <div id="cyl-results"><p class="text-muted">No probe results yet.</p></div>
        <div class="results-actions" id="cyl-results-actions" style="display: none;">
          <button onclick="setCylinderZero('X')">Set X0</button>
          <button onclick="setCylinderZero('Y')">Set Y0</button>
          <button onclick="setCylinderZero('XY')" class="btn-primary">Set XY0</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="cyl-repeatability-mode" onchange="toggleCylRepeatability()">
            Repeatability Test Mode
          </label>
        </div>
        <div id="cyl-history"><p class="text-muted">Enable repeatability mode to compare runs.</p></div>
        <div id="cyl-history-actions" style="display: none; margin-top: 8px;">
          <button onclick="clearCylinderHistory()">Clear History</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- HOLE PROBE TAB (placeholder) -->

<!-- HOLE PROBE TAB -->
<div class="tab-panel" id="panel-hole">
  <div class="probe-layout">
    <div>
      <div class="section">
        <div class="section-title">Presets</div>
        <div class="preset-row">
          <select id="hole-preset-select"><option value="">-- Select Preset --</option></select>
          <button onclick="loadHolePreset()">Load</button>
          <button onclick="saveHolePreset()">Save</button>
          <button onclick="deleteHolePreset()">Delete</button>
        </div>
      </div>
      <div class="section probe-params">
        <div class="section-title">Parameters</div>
        <div class="form-row">
          <span class="form-label">Preset Name:</span>
          <input type="text" id="hole-preset-name" placeholder="e.g., 20mm Bore">
        </div>
        <div class="form-row">
          <span class="form-label">Hole Ø (approx):</span>
          <div class="input-with-unit">
            <input type="number" id="hole-diameter" value="20" min="5" step="0.1" onchange="updateHoleProbeDistance()">
            <span class="unit-suffix">mm</span>
          </div>
        </div>
        <div class="form-row">
          <span class="form-label">Probe Distance:</span>
          <div class="input-with-unit">
            <input type="number" id="hole-probe-distance" value="12" min="1" step="0.5">
            <span class="unit-suffix">mm</span>
          </div>
          <span class="text-muted" style="font-size: 11px;">(auto: Ø/2 + 2)</span>
        </div>
        <div class="form-row">
          <span class="form-label">Feedrate:</span>
          <div class="input-with-unit">
            <input type="number" id="hole-feedrate" value="100" min="10" step="10">
            <span class="unit-suffix">mm/min</span>
          </div>
        </div>
        <div class="form-row">
          <span class="form-label">Probe Tip Ø:</span>
          <div class="input-with-unit">
            <input type="number" id="hole-tip-dia" value="2.0" readonly disabled>
            <span class="unit-suffix">mm</span>
          </div>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Actions</div>
        <div id="hole-probe-status"></div>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button onclick="testProbeConnection('hole')" class="btn-primary">Test Probe</button>
          <button onclick="runHoleProbe()" class="btn-success" id="hole-run-btn">▶ Run Probe</button>
        </div>
      </div>
    </div>
    <div>
      <div class="section">
        <div class="section-title">Results</div>
        <div id="hole-results"><p class="text-muted">No probe results yet.</p></div>
        <div class="results-actions" id="hole-results-actions" style="display: none;">
          <button onclick="setHoleZero('X')">Set X0</button>
          <button onclick="setHoleZero('Y')">Set Y0</button>
          <button onclick="setHoleZero('XY')" class="btn-primary">Set XY0</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="hole-repeatability-mode" onchange="toggleHoleRepeatability()">
            Repeatability Test Mode
          </label>
        </div>
        <div id="hole-history"><p class="text-muted">Enable repeatability mode to compare runs.</p></div>
        <div id="hole-history-actions" style="display: none; margin-top: 8px;">
          <button onclick="clearHoleHistory()">Clear History</button>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- CORNER PROBE TAB -->
<div class="tab-panel" id="panel-corner">
  <div class="probe-layout">
    <div>
      <div class="section">
        <div class="section-title">Presets</div>
        <div class="preset-row">
          <select id="corner-preset-select"><option value="">-- Select Preset --</option></select>
          <button onclick="loadCornerPreset()">Load</button>
          <button onclick="saveCornerPreset()">Save</button>
          <button onclick="deleteCornerPreset()">Delete</button>
        </div>
      </div>
      <div class="section probe-params">
        <div class="section-title">Parameters</div>
        <div class="form-row">
          <span class="form-label">Preset Name:</span>
          <input type="text" id="corner-preset-name" placeholder="e.g., Front Left">
        </div>
        <div class="form-row">
          <span class="form-label">Corner Location:</span>
          <select id="corner-location" style="width: 250px;">
            <option value="SW">SW - Southwest (Bottom-Left)</option>
            <option value="SE">SE - Southeast (Bottom-Right)</option>
            <option value="NW">NW - Northwest (Top-Left)</option>
            <option value="NE">NE - Northeast (Top-Right)</option>
          </select>
        </div>
        <div class="form-row">
          <span class="form-label">Corner Type:</span>
          <select id="corner-type" style="width: 250px;">
            <option value="outside">Outside Corner (workpiece edge)</option>
            <option value="inside" disabled>Inside Corner (coming soon)</option>
          </select>
        </div>
        <div class="form-row">
          <span class="form-label">Start Distance (A):</span>
          <div class="input-with-unit">
            <input type="number" id="corner-start-dist" value="5" min="1" step="0.5">
            <span class="unit-suffix">mm</span>
          </div>
          <span style="font-size: 12px; color: #999; margin-left: 8px;">Distance from each wall at start</span>
        </div>
        <div class="form-row">
          <span class="form-label">Travel Distance (2→B):</span>
          <div class="input-with-unit">
            <input type="number" id="corner-travel-dist" value="10" min="2" step="1">
            <span class="unit-suffix">mm</span>
          </div>
          <span style="font-size: 12px; color: #999; margin-left: 8px;">Auto: 2× start distance</span>
        </div>
        <div class="form-row">
          <span class="form-label">Feedrate:</span>
          <div class="input-with-unit">
            <input type="number" id="corner-feedrate" value="100" min="10" step="10">
            <span class="unit-suffix">mm/min</span>
          </div>
        </div>
        <div class="form-row">
          <span class="form-label">Move to Corner:</span>
          <input type="checkbox" id="corner-move-to-corner" checked style="width: auto; margin-left: 8px;">
          <span style="font-size: 12px; color: #999; margin-left: 8px;">Raise Z and move to corner at end</span>
        </div>
        <div class="form-row">
          <span class="form-label">Z Safe Distance:</span>
          <div class="input-with-unit">
            <input type="number" id="corner-z-safe" value="10" min="1" step="1">
            <span class="unit-suffix">mm</span>
          </div>
          <span style="font-size: 12px; color: #999; margin-left: 8px;">Relative: raise Z this amount from current position</span>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Setup Instructions</div>
        <div style="font-size: 13px; line-height: 1.6; color: #ccc;">
          <p><strong>OUTSIDE Corner Positioning:</strong></p>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li><strong>SW (Southwest/Bottom-Left):</strong> Position probe LEFT of vertical wall, BELOW horizontal wall</li>
            <li><strong>SE (Southeast/Bottom-Right):</strong> Position probe RIGHT of vertical wall, BELOW horizontal wall</li>
            <li><strong>NW (Northwest/Top-Left):</strong> Position probe LEFT of vertical wall, ABOVE horizontal wall</li>
            <li><strong>NE (Northeast/Top-Right):</strong> Position probe RIGHT of vertical wall, ABOVE horizontal wall</li>
          </ul>
          <p style="margin-top: 10px;"><strong>Start Position (A):</strong></p>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li>Set Z at mid-height of workpiece sidewall</li>
            <li>Position probe at "Start Distance" from BOTH walls (default 5mm)</li>
            <li>Probe will move in L-shaped pattern to find both walls</li>
          </ul>
          <p style="margin-top: 10px; color: #ff9800;"><strong>Sequence:</strong> (1) Probe first wall → (2) Move parallel → (3) Move past first wall → (4) Probe second wall → Done or move to corner</p>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Actions</div>
        <div id="corner-probe-status"></div>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button onclick="testProbeConnection('corner')" class="btn-primary">Test Probe</button>
          <button onclick="runCornerProbe()" class="btn-success" id="corner-run-btn">▶ Run Probe</button>
        </div>
      </div>
    </div>
    <div>
      <div class="section">
        <div class="section-title">Results</div>
        <div id="corner-results"><p class="text-muted">No probe results yet.</p></div>
        <div class="results-actions" id="corner-results-actions" style="display: none;">
          <button onclick="setCornerZero('X')">Set X0</button>
          <button onclick="setCornerZero('Y')">Set Y0</button>
          <button onclick="setCornerZero('XY')" class="btn-primary">Set XY0</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Instructions</div>
        <div style="font-size: 12px; line-height: 1.6;">
          <p><strong>Inside Corner:</strong> Position probe tip near the corner, inside the workpiece. Probe will search outward to find both edges.</p>
          <p style="margin-top: 8px;"><strong>Outside Corner:</strong> Position probe tip outside the corner. Probe will search inward to find both edges.</p>
          <p style="margin-top: 8px;"><strong>Corner Type:</strong> Select quadrant based on which direction the corner extends (+X is right, +Y is away from you).</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- SIDE ALIGN TAB -->
<div class="tab-panel" id="panel-side-align">
  <div class="section">
    <div class="section-title">Side Probe Settings</div>

    <div class="form-row">
      <span class="form-label">Probe Direction:</span>
      <select id="side-probe-direction" style="width: 250px;">
        <option value="+X">Right (+X)</option>
        <option value="-X">Left (-X)</option>
        <option value="+Y">Up (+Y)</option>
        <option value="-Y">Down (-Y)</option>
      </select>
    </div>

    <div class="form-row">
      <span class="form-label">Probe Distance:</span>
      <div class="input-with-unit">
        <input type="number" id="side-probe-distance" value="5" min="1" step="0.5">
        <span class="unit-suffix">mm</span>
      </div>
      <span style="font-size: 12px; color: #999; margin-left: 8px;">Distance from edge to start position</span>
    </div>

    <div class="form-row">
      <span class="form-label">Feedrate:</span>
      <div class="input-with-unit">
        <input type="number" id="side-probe-feedrate" value="100" min="10" step="10">
        <span class="unit-suffix">mm/min</span>
      </div>
    </div>

    <div class="form-row">
      <span class="form-label">Slow Feedrate:</span>
      <div class="input-with-unit">
        <input type="number" id="side-probe-feedrate-slow" value="25" min="5" step="5">
        <span class="unit-suffix">mm/min</span>
      </div>
    </div>

    <div class="form-row">
      <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
        <input type="checkbox" id="side-raise-z" style="width: auto;">
        <span>Raise Z before moving between points</span>
      </label>
      <span style="font-size: 12px; color: #999; margin-left: 24px;">For "Probe Both Points" auto-sequence</span>
    </div>

    <div class="form-row">
      <span class="form-label">Z Safe Distance:</span>
      <div class="input-with-unit">
        <input type="number" id="side-z-safe" value="10" min="1" step="1">
        <span class="unit-suffix">mm</span>
      </div>
      <span style="font-size: 12px; color: #999; margin-left: 8px;">Relative: raise Z this amount</span>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Point Status</div>

    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
      <div style="flex: 1;">
        <div style="font-weight: bold; margin-bottom: 5px;">Point 1:</div>
        <div id="side-point1-status" style="color: #999;">Not Set</div>
        <div id="side-point1-coords" style="font-size: 12px; color: #666; margin-top: 3px;"></div>
      </div>
      <div style="flex: 1;">
        <div style="font-weight: bold; margin-bottom: 5px;">Point 2:</div>
        <div id="side-point2-status" style="color: #999;">Not Set</div>
        <div id="side-point2-coords" style="font-size: 12px; color: #666; margin-top: 3px;"></div>
      </div>
    </div>

    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
      <button id="btn-side-set-point1" class="btn" onclick="setSidePoint1AndProbe()">Set Point 1 &amp; Probe</button>
      <button id="btn-side-set-point2" class="btn" onclick="setSidePoint2AndProbe()" disabled>Set Point 2 &amp; Probe</button>
      <button id="btn-side-reprobe-point2" class="btn" onclick="reprobeSidePoint2()" disabled>Re-Probe Point 2</button>
      <button id="btn-side-probe-both" class="btn" onclick="probeBothSidePoints()" disabled>Probe Both Points</button>
      <button id="btn-side-clear" class="btn" onclick="clearSidePoints()" disabled>Clear All Points</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Results</div>
    <div id="side-results" style="min-height: 100px; padding: 10px; background: #2a2a2a; border-radius: 4px; font-family: monospace; font-size: 13px; white-space: pre-wrap;">
Ready to probe. Manually jog to first point and click "Set Point 1 &amp; Probe".
    </div>
  </div>

  <div class="section">
    <div class="section-title">Jog Controls</div>

    <div class="jog-container">
      <div>
        <div class="jog-xy">
          <div class="jog-placeholder"></div>
          <button class="jog-btn" data-axis="Y" data-dir="+">▲</button>
          <div class="jog-placeholder"></div>
          <button class="jog-btn" data-axis="X" data-dir="-">◀</button>
          <div class="jog-placeholder"></div>
          <button class="jog-btn" data-axis="X" data-dir="+">▶</button>
          <div class="jog-placeholder"></div>
          <button class="jog-btn" data-axis="Y" data-dir="-">▼</button>
          <div class="jog-placeholder"></div>
        </div>
        <div class="jog-label">XY</div>
      </div>
    </div>
    <p class="text-muted mt-1" style="text-align: center; font-size: 11px;">Click and hold to jog</p>
  </div>
</div>

<!-- HEIGHT MAP TAB -->
<div class="tab-panel" id="panel-heightmap">
  <div class="section">
    <div class="section-title">Preset Management</div>
    <div class="form-row">
      <span class="form-label">Preset Name:</span>
      <input type="text" id="hm-preset-name" placeholder="e.g., 4040 Pro Max" style="flex: 1;">
    </div>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
      <button class="btn btn-primary" onclick="saveHeightmapPreset()">Save Current as Preset</button>
      <select id="hm-preset-list" style="flex: 1;" onchange="loadHeightmapPreset()">
        <option value="">-- Load Preset --</option>
      </select>
      <button class="btn" onclick="deleteHeightmapPreset()">Delete Preset</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">T-Slot Configuration</div>
    <div class="form-row">
      <span class="form-label">Slot X Positions:</span>
      <input type="text" id="hm-slot-x" value="0,60,140.3,200.3,280.6,340.6" style="flex: 1;">
      <span class="unit-suffix">mm</span>
    </div>
    <div class="form-row">
      <span class="form-label">Y Positions:</span>
      <input type="text" id="hm-y-pos" value="0,50,100,150,200,250,300,350,380" style="flex: 1;">
      <span class="unit-suffix">mm</span>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Probe Settings</div>
    <div class="form-row">
      <span class="form-label">Probe Depth:</span>
      <div class="input-with-unit">
        <input type="number" id="hm-probe-depth" value="-10" step="0.5" max="-0.5">
        <span class="unit-suffix">mm</span>
      </div>
      <span style="font-size: 12px; color: #999; margin-left: 8px;">How far to probe down from Z=0</span>
    </div>
    <div class="form-row">
      <span class="form-label">Feedrate:</span>
      <div class="input-with-unit">
        <input type="number" id="hm-feedrate" value="100" step="10">
        <span class="unit-suffix">mm/min</span>
      </div>
    </div>
    <div class="form-row">
      <span class="form-label">Timeout:</span>
      <div class="input-with-unit">
        <input type="number" id="hm-timeout" value="30" step="5">
        <span class="unit-suffix">sec</span>
      </div>
      <span style="font-size: 12px; color: #999; margin-left: 8px;">Watchdog per command</span>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Start Probing</div>
    <p class="text-muted" style="margin-bottom: 10px;">
      Position probe at first point (SW t-slot rail, X=0 Y=0) and set work coordinate system.
    </p>
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
      <button class="btn" onclick="setHeightmapStartPoint()">Set Start Point (G10 L20 P1 X0 Y0)</button>
      <button class="btn btn-primary" id="btn-hm-start" onclick="startHeightmapProbe()">Start Probing</button>
      <button class="btn" id="btn-hm-abort" onclick="abortHeightmapProbe()" disabled style="background: #c00; color: white;">Abort</button>
    </div>
    <div id="hm-progress" style="font-weight: bold; color: #4a9eff; margin-bottom: 10px;"></div>
  </div>

  <div class="section">
    <div class="section-title">Results</div>
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
      <button class="btn" id="btn-hm-export-csv" onclick="exportHeightmapCSV()" disabled>Export CSV</button>
      <button class="btn" id="btn-hm-export-html" onclick="exportHeightmapHTML()" disabled>Export HTML Report</button>
    </div>
    <div id="hm-results" style="min-height: 150px; padding: 10px; background: #2a2a2a; border-radius: 4px; font-family: monospace; font-size: 13px; white-space: pre-wrap; max-height: 300px; overflow: auto;">
No data yet. Position probe and click "Start Probing".
    </div>
  </div>
</div>

<!-- SETTINGS TAB -->
<div class="tab-panel" id="panel-settings">
  <div class="settings-grid">
    <div class="section">
      <div class="section-title">Connection</div>
      <div class="form-row">
        <span class="form-label">IP Address:</span>
        <input type="text" id="setting-ip" value="192.168.73.13">
      </div>
      <div class="form-row">
        <span class="form-label">Port:</span>
        <input type="number" id="setting-port" value="81">
      </div>
    </div>
    <div class="section">
      <div class="section-title">Probe Settings</div>
      <div class="form-row">
        <span class="form-label">Tip Diameter:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-tip-dia" value="2.0" step="0.1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Feedrate:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-feedrate" value="100" step="10">
          <span class="unit-suffix">mm/min</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Slow Feedrate:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-feedrate-slow" value="50" step="10">
          <span class="unit-suffix">mm/min</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Timeout:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-timeout" value="30" step="5">
          <span class="unit-suffix">sec</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Retract Distance:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-retract" value="2.0" step="0.5">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Jog Settings</div>
      <div class="form-row">
        <span class="form-label">XY Speed:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-jog-xy" value="1800" step="100">
          <span class="unit-suffix">mm/min</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Z Speed:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-jog-z" value="400" step="50">
          <span class="unit-suffix">mm/min</span>
        </div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Output Commands</div>
      <div class="form-row">
        <span class="form-label">Mist On:</span>
        <input type="text" id="setting-mist-on" value="M7">
      </div>
      <div class="form-row">
        <span class="form-label">Mist Off:</span>
        <input type="text" id="setting-mist-off" value="M9">
      </div>
      <div class="form-row">
        <span class="form-label">Vacuum On:</span>
        <input type="text" id="setting-vacuum-on" value="M8">
      </div>
      <div class="form-row">
        <span class="form-label">Vacuum Off:</span>
        <input type="text" id="setting-vacuum-off" value="M9">
      </div>
      <div class="form-row">
        <span class="form-label">IoT On:</span>
        <input type="text" id="setting-iot-on" value="M64 P0">
      </div>
      <div class="form-row">
        <span class="form-label">IoT Off:</span>
        <input type="text" id="setting-iot-off" value="M65 P0">
      </div>
    </div>
    <div class="section">
      <div class="section-title">Default Probe Distances</div>
      <div class="form-row">
        <span class="form-label">Cylinder Probe:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-cyl-distance" value="20" step="1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Hole Probe:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-hole-distance" value="20" step="1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Corner Probe:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-corner-distance" value="20" step="1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Side Probe:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-side-distance" value="5" step="0.5">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
    </div>
    <div class="section">
      <div class="section-title">Default Z Safe Heights</div>
      <div class="form-row">
        <span class="form-label">Cylinder/Hole/Corner:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-z-safe" value="10" step="1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Side Probe:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-side-z-safe" value="10" step="1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
      <div class="form-row">
        <span class="form-label">Height Map:</span>
        <div class="input-with-unit">
          <input type="number" id="setting-default-heightmap-z-safe" value="20" step="1">
          <span class="unit-suffix">mm</span>
        </div>
      </div>
    </div>
  </div>
  <div class="section">
    <div class="section-title">Presets Summary</div>
    <p id="cylinder-preset-count" class="text-muted">0 cylinder presets saved</p>
    <p id="hole-preset-count" class="text-muted">0 hole presets saved</p>
    <p id="corner-preset-count" class="text-muted">0 corner presets saved</p>
    <p id="heightmap-preset-count" class="text-muted">0 heightmap presets saved</p>
  </div>
  <div class="section">
    <div class="section-title">JSON Settings Editor</div>
    <textarea id="settings-json"></textarea>
    <div class="json-actions">
      <button id="refresh-json-btn">Refresh</button>
      <button id="apply-json-btn" class="btn-primary">Apply</button>
      <button id="format-json-btn">Format</button>
    </div>
  </div>
  <div class="instructions">
    <strong>To Save Settings:</strong> Use browser File → Save As (Ctrl+S) to save the HTML file with your settings embedded.
  </div>
</div>

</main>

<footer id="status-bar">
  <span>Connection: <span id="footer-connection" class="text-danger">Disconnected</span></span>
  <span>Alarm: <span id="footer-alarm" class="alarm-status">None</span></span>
</footer>
</div>

<!-- EMBEDDED SETTINGS (survives Save-As) -->
<script id="user-settings" type="application/json">
{
  "connection": { "ip": "192.168.73.13", "port": 81 },
  "probe": {
    "tipDiameter": 2.0,
    "feedrate": 100,
    "feedrateSlow": 50,
    "timeout": 30,
    "retractDistance": 2.0
  },
  "jog": { "xySpeed": 1800, "zSpeed": 400 },
  "outputs": {
    "mistOn": "M7", "mistOff": "M9",
    "vacuumOn": "M8", "vacuumOff": "M9",
    "iotOn": "M64 P0", "iotOff": "M65 P0"
  },
  "defaults": {
    "probeDistances": {
      "cylinder": 20,
      "hole": 20,
      "corner": 20,
      "side": 5
    },
    "zSafeHeights": {
      "standard": 10,
      "side": 10,
      "heightmap": 20
    }
  },
  "presets": { "cylinder": [], "hole": [], "corner": [], "heightmap": [] }
}
</script>


<script>
//#region ===== GLOBAL STATE =====
const VERSION = '1.13.3';
const App = {
  ws: null,
  isConnected: false,
  settings: null,
  alarmState: 'None',
  position: {
    mcs: { x: 0, y: 0, z: 0 },
    wcs: { x: 0, y: 0, z: 0 }
  },
  wco: { x: 0, y: 0, z: 0 },
  isJogging: false,
  probeInProgress: false  // Shared flag for any probe operation
};
//#endregion

//#region ===== SETTINGS MANAGEMENT =====
function loadSettings() {
  try {
    const el = document.getElementById('user-settings');
    App.settings = JSON.parse(el.textContent);
  } catch (e) {
    console.error('Failed to load settings:', e);
    App.settings = getDefaultSettings();
  }
  applySettingsToUI();
  updateSettingsJSON();
}

function getDefaultSettings() {
  return {
    connection: { ip: "192.168.73.13", port: 81 },
    probe: { tipDiameter: 2.0, feedrate: 100, feedrateSlow: 50, timeout: 30, retractDistance: 2.0 },
    jog: { xySpeed: 1800, zSpeed: 400 },
    outputs: { mistOn: "M7", mistOff: "M9", vacuumOn: "M8", vacuumOff: "M9", iotOn: "M64 P0", iotOff: "M65 P0" },
    defaults: {
      probeDistances: { cylinder: 20, hole: 20, corner: 20, side: 5 },
      zSafeHeights: { standard: 10, side: 10, heightmap: 20 }
    },
    presets: { cylinder: [], hole: [], corner: [], heightmap: [] }
  };
}

function applySettingsToUI() {
  document.getElementById('ip-input').value = App.settings.connection.ip;
  document.getElementById('port-input').value = App.settings.connection.port;
  document.getElementById('setting-ip').value = App.settings.connection.ip;
  document.getElementById('setting-port').value = App.settings.connection.port;
  document.getElementById('setting-tip-dia').value = App.settings.probe.tipDiameter;
  document.getElementById('setting-feedrate').value = App.settings.probe.feedrate;
  document.getElementById('setting-feedrate-slow').value = App.settings.probe.feedrateSlow;
  document.getElementById('setting-timeout').value = App.settings.probe.timeout;
  document.getElementById('setting-retract').value = App.settings.probe.retractDistance;
  document.getElementById('setting-jog-xy').value = App.settings.jog.xySpeed;
  document.getElementById('setting-jog-z').value = App.settings.jog.zSpeed;
  document.getElementById('setting-mist-on').value = App.settings.outputs.mistOn;
  document.getElementById('setting-mist-off').value = App.settings.outputs.mistOff;
  document.getElementById('setting-vacuum-on').value = App.settings.outputs.vacuumOn;
  document.getElementById('setting-vacuum-off').value = App.settings.outputs.vacuumOff;
  document.getElementById('setting-iot-on').value = App.settings.outputs.iotOn;
  document.getElementById('setting-iot-off').value = App.settings.outputs.iotOff;

  // Default probe distances
  if (App.settings.defaults && App.settings.defaults.probeDistances) {
    document.getElementById('setting-default-cyl-distance').value = App.settings.defaults.probeDistances.cylinder;
    document.getElementById('setting-default-hole-distance').value = App.settings.defaults.probeDistances.hole;
    document.getElementById('setting-default-corner-distance').value = App.settings.defaults.probeDistances.corner;
    document.getElementById('setting-default-side-distance').value = App.settings.defaults.probeDistances.side;
  }

  // Default Z safe heights
  if (App.settings.defaults && App.settings.defaults.zSafeHeights) {
    document.getElementById('setting-default-z-safe').value = App.settings.defaults.zSafeHeights.standard;
    document.getElementById('setting-default-side-z-safe').value = App.settings.defaults.zSafeHeights.side;
    document.getElementById('setting-default-heightmap-z-safe').value = App.settings.defaults.zSafeHeights.heightmap;
  }

  document.getElementById('cyl-tip-dia').value = App.settings.probe.tipDiameter;
  document.getElementById('hole-tip-dia').value = App.settings.probe.tipDiameter;
  updatePresetCounts();
}

function collectSettingsFromUI() {
  return {
    connection: {
      ip: document.getElementById('setting-ip').value,
      port: parseInt(document.getElementById('setting-port').value) || 81
    },
    probe: {
      tipDiameter: parseFloat(document.getElementById('setting-tip-dia').value) || 2.0,
      feedrate: parseInt(document.getElementById('setting-feedrate').value) || 100,
      feedrateSlow: parseInt(document.getElementById('setting-feedrate-slow').value) || 50,
      timeout: parseInt(document.getElementById('setting-timeout').value) || 30,
      retractDistance: parseFloat(document.getElementById('setting-retract').value) || 2.0
    },
    jog: {
      xySpeed: parseInt(document.getElementById('setting-jog-xy').value) || 1800,
      zSpeed: parseInt(document.getElementById('setting-jog-z').value) || 400
    },
    outputs: {
      mistOn: document.getElementById('setting-mist-on').value,
      mistOff: document.getElementById('setting-mist-off').value,
      vacuumOn: document.getElementById('setting-vacuum-on').value,
      vacuumOff: document.getElementById('setting-vacuum-off').value,
      iotOn: document.getElementById('setting-iot-on').value,
      iotOff: document.getElementById('setting-iot-off').value
    },
    defaults: {
      probeDistances: {
        cylinder: parseFloat(document.getElementById('setting-default-cyl-distance').value) || 20,
        hole: parseFloat(document.getElementById('setting-default-hole-distance').value) || 20,
        corner: parseFloat(document.getElementById('setting-default-corner-distance').value) || 20,
        side: parseFloat(document.getElementById('setting-default-side-distance').value) || 5
      },
      zSafeHeights: {
        standard: parseFloat(document.getElementById('setting-default-z-safe').value) || 10,
        side: parseFloat(document.getElementById('setting-default-side-z-safe').value) || 10,
        heightmap: parseFloat(document.getElementById('setting-default-heightmap-z-safe').value) || 20
      }
    },
    presets: App.settings.presets
  };
}

function updateSettingsJSON() {
  document.getElementById('settings-json').value = JSON.stringify(App.settings, null, 2);
}

function saveSettingsToEmbedded() {
  const el = document.getElementById('user-settings');
  if (el) el.textContent = JSON.stringify(App.settings, null, 2);
}

function setupSettingsAutoSave() {
  const inputs = document.querySelectorAll('#panel-settings input, #panel-settings select');
  inputs.forEach(input => {
    input.addEventListener('change', () => {
      App.settings = collectSettingsFromUI();
      saveSettingsToEmbedded();
      updateSettingsJSON();
      document.getElementById('cyl-tip-dia').value = App.settings.probe.tipDiameter;
      document.getElementById('hole-tip-dia').value = App.settings.probe.tipDiameter;
    });
  });
}

function onRefreshJSON() {
  App.settings = collectSettingsFromUI();
  updateSettingsJSON();
  saveSettingsToEmbedded();
}

function onApplyJSON() {
  try {
    App.settings = JSON.parse(document.getElementById('settings-json').value);
    applySettingsToUI();
    saveSettingsToEmbedded();
    alert('Settings applied!');
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
}

function onFormatJSON() {
  try {
    const obj = JSON.parse(document.getElementById('settings-json').value);
    document.getElementById('settings-json').value = JSON.stringify(obj, null, 2);
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
}

function updatePresetCounts() {
  document.getElementById('cylinder-preset-count').textContent = App.settings.presets.cylinder.length + ' cylinder presets saved';
  document.getElementById('hole-preset-count').textContent = App.settings.presets.hole.length + ' hole presets saved';
  document.getElementById('corner-preset-count').textContent = App.settings.presets.corner.length + ' corner presets saved';
  document.getElementById('heightmap-preset-count').textContent = (App.settings.presets.heightmap || []).length + ' heightmap presets saved';
}
//#endregion

//#region ===== WEBSOCKET CONNECTION =====
function connect() {
  if (App.isConnected) return;
  const ip = document.getElementById('ip-input').value.trim();
  const port = document.getElementById('port-input').value.trim();
  const url = 'ws://' + ip + ':' + port + '/';
  console.log('Connecting to', url);
  
  try {
    App.ws = new WebSocket(url);
  } catch (e) {
    console.error('Connection failed:', e);
    return;
  }
  
  App.ws.onopen = () => {
    App.isConnected = true;
    updateConnectionStatus('connected');
    sendCommand('?');
    sendCommand('$#');
    setTimeout(() => sendCommand('?'), 300);
  };
  
  App.ws.onclose = () => {
    App.isConnected = false;
    updateConnectionStatus('disconnected');
  };
  
  App.ws.onerror = (e) => {
    console.error('WebSocket error:', e);
    updateConnectionStatus('disconnected');
  };
  
  App.ws.onmessage = async (event) => {
    let data = event.data;
    if (data instanceof Blob) data = await data.text();
    handleMessage(data);
  };
}

function disconnect() {
  if (App.ws) { App.ws.close(); App.ws = null; }
  App.isConnected = false;
  updateConnectionStatus('disconnected');
}

function sendCommand(cmd) {
  if (App.ws && App.isConnected) {
    console.log('>> ' + cmd);
    App.ws.send(cmd + '\n');
    return true;
  }
  return false;
}

function updateConnectionStatus(status) {
  const dot = document.getElementById('status-dot');
  const text = document.getElementById('status-text');
  const footer = document.getElementById('footer-connection');
  const connectBtn = document.getElementById('connect-btn');
  const disconnectBtn = document.getElementById('disconnect-btn');
  
  if (status === 'connected') {
    dot.className = 'status-dot connected';
    text.textContent = 'Connected';
    footer.textContent = 'Connected';
    footer.className = 'text-success';
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
  } else {
    dot.className = 'status-dot';
    text.textContent = 'Disconnected';
    footer.textContent = 'Disconnected';
    footer.className = 'text-danger';
    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
  }
}
//#endregion

//#region ===== MESSAGE HANDLING =====
function handleMessage(raw) {
  for (const line of raw.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    console.log('<< ' + trimmed);
    
    if (trimmed.startsWith('<') && trimmed.endsWith('>')) {
      parseStatusReport(trimmed);
    } else if (trimmed.startsWith('[G54:')) {
      parseG54Offset(trimmed);
    } else if (trimmed.toLowerCase().startsWith('alarm:') || trimmed.includes('ALARM:')) {
      setAlarmState(trimmed);
    }
  }
}

function parseStatusReport(report) {
  const content = report.slice(1, -1);
  const parts = content.split('|');
  
  if (parts[0].toLowerCase().includes('alarm')) setAlarmState(parts[0]);
  else clearAlarmState();
  
  for (const part of parts) {
    if (part.startsWith('MPos:')) {
      const c = part.substring(5).split(',');
      if (c.length >= 3) {
        App.position.mcs.x = parseFloat(c[0]) || 0;
        App.position.mcs.y = parseFloat(c[1]) || 0;
        App.position.mcs.z = parseFloat(c[2]) || 0;
        App.position.wcs.x = App.position.mcs.x - App.wco.x;
        App.position.wcs.y = App.position.mcs.y - App.wco.y;
        App.position.wcs.z = App.position.mcs.z - App.wco.z;
      }
    }
  }
  updatePositionDisplay();
}

function parseG54Offset(line) {
  const match = line.match(/\[G54:([-\d.]+),([-\d.]+),([-\d.]+)/);
  if (match) {
    App.wco.x = parseFloat(match[1]) || 0;
    App.wco.y = parseFloat(match[2]) || 0;
    App.wco.z = parseFloat(match[3]) || 0;
    console.log('G54 offset:', App.wco);
    App.position.wcs.x = App.position.mcs.x - App.wco.x;
    App.position.wcs.y = App.position.mcs.y - App.wco.y;
    App.position.wcs.z = App.position.mcs.z - App.wco.z;
    updatePositionDisplay();
  }
}

function setAlarmState(alarm) {
  App.alarmState = alarm;
  const el = document.getElementById('footer-alarm');
  el.textContent = alarm;
  el.className = 'alarm-status alarm';
}

function clearAlarmState() {
  if (App.alarmState !== 'None') {
    App.alarmState = 'None';
    const el = document.getElementById('footer-alarm');
    el.textContent = 'None';
    el.className = 'alarm-status';
  }
}
//#endregion

//#region ===== EMERGENCY STOP =====
function emergencyStop() {
  console.log('*** EMERGENCY STOP ***');
  if (App.ws && App.isConnected) {
    App.ws.send('!');
    setTimeout(() => { if (App.ws && App.isConnected) App.ws.send('\x18'); }, 100);
  }
  stopContinuousJog();
  App.probeInProgress = false;
}
//#endregion

//#region ===== TAB NAVIGATION =====
function setupTabs() {
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      document.getElementById('panel-' + btn.dataset.tab).classList.add('active');
    });
  });
}
//#endregion

//#region ===== CONTROL TAB =====
function updatePositionDisplay() {
  document.getElementById('pos-mcs-x').textContent = App.position.mcs.x.toFixed(3);
  document.getElementById('pos-mcs-y').textContent = App.position.mcs.y.toFixed(3);
  document.getElementById('pos-mcs-z').textContent = App.position.mcs.z.toFixed(3);
  document.getElementById('pos-wcs-x').textContent = App.position.wcs.x.toFixed(3);
  document.getElementById('pos-wcs-y').textContent = App.position.wcs.y.toFixed(3);
  document.getElementById('pos-wcs-z').textContent = App.position.wcs.z.toFixed(3);
}

function refreshPosition() {
  if (sendCommand('?')) console.log('Position refresh requested');
  sendCommand('$#');
}

function zeroAxis(axis) {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (axis === 'XY') sendCommand('G10 L20 P1 X0 Y0');
  else sendCommand('G10 L20 P1 ' + axis + '0');
  setTimeout(() => { sendCommand('$#'); setTimeout(() => sendCommand('?'), 100); }, 100);
}

function gotoZero(axis) {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (axis === 'XY') sendCommand('G90 G0 X0 Y0');
  else sendCommand('G90 G0 ' + axis + '0');
}

function homeAxis(axis) {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (axis === 'all') sendCommand('$H');
  else sendCommand('$H' + axis);
}

const outputState = { mist: false, vacuum: false, iot: false };
function toggleOutput(output) {
  if (!App.isConnected) { alert('Not connected'); return; }
  outputState[output] = !outputState[output];
  const btn = document.getElementById(output + '-btn');
  let cmd;
  if (output === 'mist') cmd = outputState[output] ? App.settings.outputs.mistOn : App.settings.outputs.mistOff;
  else if (output === 'vacuum') cmd = outputState[output] ? App.settings.outputs.vacuumOn : App.settings.outputs.vacuumOff;
  else if (output === 'iot') cmd = outputState[output] ? App.settings.outputs.iotOn : App.settings.outputs.iotOff;
  sendCommand(cmd);
  btn.textContent = outputState[output] ? 'ON' : 'OFF';
  btn.classList.toggle('active', outputState[output]);
}

function setupJogButtons() {
  document.querySelectorAll('.jog-btn').forEach(btn => {
    const start = (e) => { e.preventDefault(); startContinuousJog(btn.dataset.axis, btn.dataset.dir); };
    const stop = () => stopContinuousJog();
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', stop);
    btn.addEventListener('mouseleave', stop);
    btn.addEventListener('touchstart', start);
    btn.addEventListener('touchend', stop);
    btn.addEventListener('touchcancel', stop);
  });
}

function startContinuousJog(axis, dir) {
  if (!App.isConnected) return;
  App.isJogging = true;
  const speed = (axis === 'Z') ? App.settings.jog.zSpeed : App.settings.jog.xySpeed;
  const distance = (dir === '+') ? 1000 : -1000;
  sendCommand('$J=G91 G21 ' + axis + distance + ' F' + speed);
}

function stopContinuousJog() {
  if (App.isJogging) {
    App.isJogging = false;
    if (App.ws && App.isConnected) App.ws.send(String.fromCharCode(0x85));
  }
}
//#endregion

//#region ===== SHARED PROBE UTILITIES =====
// These utilities are used by all probe operations (Cylinder, Hole, Corner, etc.)

// Command ID counter for debug logging
let probeCommandId = 0;

// Create probe helpers bound to current settings
function createProbeHelpers() {
  const timeout = (App.settings.probe.timeout || 30) * 1000;
  
  // Send command and wait for ok - sets up listener BEFORE sending
  const sendAndWait = (cmd) => new Promise((resolve, reject) => {
    const myId = ++probeCommandId;
    console.log('[' + myId + '] Sending: ' + cmd);

    const timer = setTimeout(() => {
      App.ws.removeEventListener('message', h);
      reject(new Error('Timeout waiting for ok on: ' + cmd));
    }, timeout);

    let responses = '';  // Accumulate all responses

    const h = async (ev) => {
      let d = ev.data;
      if (d instanceof Blob) d = await d.text();
      if (d.includes('PING')) return;
      console.log('[' + myId + '] Received: ' + d.trim());

      responses += d;  // Accumulate response

      if (d.includes('ok')) {
        clearTimeout(timer);
        App.ws.removeEventListener('message', h);
        console.log('[' + myId + '] OK received');
        resolve(responses);  // Return accumulated responses
      } else if (d.includes('ALARM') || d.toLowerCase().includes('error')) {
        clearTimeout(timer);
        App.ws.removeEventListener('message', h);
        reject(new Error(d.trim()));
      }
    };
    App.ws.addEventListener('message', h);
    sendCommand(cmd);
  });
  
  // Probe and capture result - sets up listener BEFORE sending
  const probeAndCapture = (axis, dist, feed) => new Promise((resolve, reject) => {
    const myId = ++probeCommandId;
    const cmd = 'G38.2 ' + axis + dist.toFixed(3) + ' F' + feed;
    console.log('[' + myId + '] Probe: ' + cmd);
    
    const timer = setTimeout(() => {
      App.ws.removeEventListener('message', h);
      reject(new Error('Probe timeout on: ' + cmd));
    }, timeout);
    
    let prb = null;
    let gotOk = false;
    
    const h = async (ev) => {
      let d = ev.data;
      if (d instanceof Blob) d = await d.text();
      if (d.includes('PING')) return;
      console.log('[' + myId + '] Received: ' + d.trim());
      
      const m = d.match(/\[PRB:([-\d.]+),([-\d.]+),([-\d.]+)(?:,[-\d.]+)?:(\d)\]/);
      if (m) {
        prb = { x: parseFloat(m[1]), y: parseFloat(m[2]), z: parseFloat(m[3]), ok: m[4] === '1' };
        console.log('[' + myId + '] PRB result:', prb);
      }
      if (d.includes('ok')) gotOk = true;
      
      if (d.includes('ALARM') || d.toLowerCase().includes('error')) {
        clearTimeout(timer);
        App.ws.removeEventListener('message', h);
        reject(new Error(d.trim()));
        return;
      }
      
      if (gotOk && prb) {
        clearTimeout(timer);
        App.ws.removeEventListener('message', h);
        if (prb.ok) {
          console.log('[' + myId + '] Probe success');
          resolve(prb);
        } else {
          reject(new Error('Probe did not trigger'));
        }
      }
    };
    App.ws.addEventListener('message', h);
    sendCommand(cmd);
  });
  
  // Move relative with proper sequencing
  const moveRel = async (axis, dist) => {
    await sendAndWait('G0 ' + axis + dist.toFixed(3));
  };
  
  return { sendAndWait, probeAndCapture, moveRel };
}

// Test probe connection - shared by all probe tabs
function testProbeConnection(probeType) {
  if (!App.isConnected) { alert('Not connected'); return; }
  const statusEl = document.getElementById(probeType + '-probe-status');
  if (!statusEl) return;
  
  statusEl.innerHTML = '<div class="probe-status working">Testing probe...</div>';
  let got = false;
  
  const check = async (event) => {
    let data = event.data;
    if (data instanceof Blob) data = await data.text();
    if (typeof data !== 'string') return;
    if (data.startsWith('<') && data.endsWith('>')) {
      got = true;
      App.ws.removeEventListener('message', check);
      if (data.includes('Pn:') && data.includes('P')) {
        statusEl.innerHTML = '<div class="probe-status error">⚠ Probe pin ACTIVE - check if touching or wiring issue</div>';
      } else {
        statusEl.innerHTML = '<div class="probe-status ready">✓ Probe Ready</div>';
      }
    }
  };
  
  App.ws.addEventListener('message', check);
  sendCommand('?');
  setTimeout(() => {
    if (!got) {
      App.ws.removeEventListener('message', check);
      statusEl.innerHTML = '<div class="probe-status error">✗ No response</div>';
    }
  }, 3000);
}

// Calculate center and diameter from probe results
function calculateProbeResults(eastX, westX, northY, southY, tipDia) {
  const centerX = (eastX + westX) / 2;
  const centerY = (northY + southY) / 2;
  const diameterX = Math.abs(eastX - westX) + tipDia;
  const diameterY = Math.abs(northY - southY) + tipDia;
  return {
    centerX,
    centerY,
    diameterX,
    diameterY,
    diameterAvg: (diameterX + diameterY) / 2
  };
}

// Calculate center and diameter for HOLE (subtract tip diameter instead of add)
function calculateHoleResults(eastX, westX, northY, southY, tipDia) {
  const centerX = (eastX + westX) / 2;
  const centerY = (northY + southY) / 2;
  const diameterX = Math.abs(eastX - westX) - tipDia;  // Subtract for internal measurement
  const diameterY = Math.abs(northY - southY) - tipDia;
  return {
    centerX,
    centerY,
    diameterX,
    diameterY,
    diameterAvg: (diameterX + diameterY) / 2
  };
}
//#endregion

//#region ===== CYLINDER PROBE =====
const CylinderProbe = { result: null, history: [] };

function updateCylProbeDistance() {
  const dia = parseFloat(document.getElementById('cyl-diameter').value) || 25;
  document.getElementById('cyl-probe-distance').value = (dia / 2 + 5).toFixed(1);
}

function loadCylinderPresets() {
  const sel = document.getElementById('cyl-preset-select');
  sel.innerHTML = '<option value="">-- Select Preset --</option>';
  App.settings.presets.cylinder.forEach((p, i) => {
    sel.innerHTML += '<option value="' + i + '">' + (p.name || 'Preset ' + (i+1)) + '</option>';
  });
}

function loadCylinderPreset() {
  const idx = parseInt(document.getElementById('cyl-preset-select').value);
  if (isNaN(idx)) return;
  const p = App.settings.presets.cylinder[idx];
  if (!p) return;
  document.getElementById('cyl-preset-name').value = p.name || '';
  document.getElementById('cyl-diameter').value = p.diameter || 25;
  document.getElementById('cyl-probe-distance').value = p.probeDistance || 17.5;
  document.getElementById('cyl-probe-depth').value = p.probeDepth || 5;
  document.getElementById('cyl-feedrate').value = p.feedrate || 100;
}

function saveCylinderPreset() {
  const name = document.getElementById('cyl-preset-name').value.trim();
  if (!name) { alert('Enter a preset name'); return; }
  const preset = {
    name: name,
    diameter: parseFloat(document.getElementById('cyl-diameter').value) || 25,
    probeDistance: parseFloat(document.getElementById('cyl-probe-distance').value) || 17.5,
    probeDepth: parseFloat(document.getElementById('cyl-probe-depth').value) || 5,
    feedrate: parseInt(document.getElementById('cyl-feedrate').value) || 100
  };
  const idx = App.settings.presets.cylinder.findIndex(p => p.name === name);
  if (idx >= 0) App.settings.presets.cylinder[idx] = preset;
  else App.settings.presets.cylinder.push(preset);
  saveSettingsToEmbedded();
  updateSettingsJSON();
  loadCylinderPresets();
  updatePresetCounts();
  alert('Preset "' + name + '" saved!');
}

function deleteCylinderPreset() {
  const idx = parseInt(document.getElementById('cyl-preset-select').value);
  if (isNaN(idx)) { alert('Select a preset to delete'); return; }
  const name = App.settings.presets.cylinder[idx].name;
  if (confirm('Delete preset "' + name + '"?')) {
    App.settings.presets.cylinder.splice(idx, 1);
    saveSettingsToEmbedded();
    updateSettingsJSON();
    loadCylinderPresets();
    updatePresetCounts();
  }
}

function setCylinderZero(axis) {
  if (!CylinderProbe.result || !App.isConnected) return;
  if (axis === 'XY') sendCommand('G10 L20 P1 X0 Y0');
  else sendCommand('G10 L20 P1 ' + axis + '0');
  setTimeout(() => { sendCommand('$#'); setTimeout(() => sendCommand('?'), 100); }, 100);
}

function toggleCylRepeatability() {
  const en = document.getElementById('cyl-repeatability-mode').checked;
  document.getElementById('cyl-history-actions').style.display = en ? 'block' : 'none';
  if (en) { CylinderProbe.history = []; updateCylinderHistory(); }
}

function clearCylinderHistory() {
  CylinderProbe.history = [];
  updateCylinderHistory();
}

function updateCylinderHistory() {
  const el = document.getElementById('cyl-history');
  if (CylinderProbe.history.length === 0) {
    el.innerHTML = '<p class="text-muted">No runs recorded yet.</p>';
    return;
  }
  const avgX = CylinderProbe.history.reduce((s, r) => s + r.centerX, 0) / CylinderProbe.history.length;
  const avgY = CylinderProbe.history.reduce((s, r) => s + r.centerY, 0) / CylinderProbe.history.length;
  let html = '<table style="width:100%;font-size:12px;border-collapse:collapse;"><tr style="color:var(--text-secondary);"><th>Run</th><th>X</th><th>Y</th><th>ΔX</th><th>ΔY</th></tr>';
  CylinderProbe.history.forEach((r, i) => {
    const dx = r.centerX - avgX, dy = r.centerY - avgY;
    html += '<tr><td>' + (i+1) + '</td><td>' + r.centerX.toFixed(3) + '</td><td>' + r.centerY.toFixed(3) + '</td><td>' + (dx>=0?'+':'') + dx.toFixed(3) + '</td><td>' + (dy>=0?'+':'') + dy.toFixed(3) + '</td></tr>';
  });
  html += '</table>';
  el.innerHTML = html;
}

function displayCylinderResults(result) {
  CylinderProbe.result = result;
  const el = document.getElementById('cyl-results');
  const expDia = parseFloat(document.getElementById('cyl-diameter').value) || 25;
  const dev = result.diameterAvg - expDia;
  el.innerHTML = '<div class="results-grid">' +
    '<span class="label">Center X:</span><span class="value">' + result.centerX.toFixed(3) + ' mm (MCS)</span>' +
    '<span class="label">Center Y:</span><span class="value">' + result.centerY.toFixed(3) + ' mm (MCS)</span>' +
    '<span class="label">Diameter X:</span><span class="value">' + result.diameterX.toFixed(3) + ' mm</span>' +
    '<span class="label">Diameter Y:</span><span class="value">' + result.diameterY.toFixed(3) + ' mm</span>' +
    '<span class="label">Avg Diameter:</span><span class="value">' + result.diameterAvg.toFixed(3) + ' mm</span>' +
    '<span class="label">Deviation:</span><span class="value">' + (dev>=0?'+':'') + dev.toFixed(3) + ' mm</span></div>';
  document.getElementById('cyl-results-actions').style.display = 'flex';
  if (document.getElementById('cyl-repeatability-mode').checked) {
    CylinderProbe.history.push(result);
    updateCylinderHistory();
  }
}

async function runCylinderProbe() {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (App.probeInProgress) { alert('Probe already running'); return; }
  
  const probeDistance = parseFloat(document.getElementById('cyl-probe-distance').value);
  const probeDepth = parseFloat(document.getElementById('cyl-probe-depth').value);
  const feedrate = parseInt(document.getElementById('cyl-feedrate').value) || 100;
  const feedrateSlow = App.settings.probe.feedrateSlow || 50;
  const retract = App.settings.probe.retractDistance || 2;
  const tipDia = App.settings.probe.tipDiameter || 2;
  
  const diameter = document.getElementById('cyl-diameter').value;
  if (!confirm('Cylinder Probe\n\nDiameter: ' + diameter + ' mm\nProbe distance: ' + probeDistance + ' mm\nProbe depth: ' + probeDepth + ' mm\n\nProbe tip is above cylinder center?\n\nContinue?')) return;
  
  App.probeInProgress = true;
  probeCommandId = 0;  // Reset command counter
  const statusEl = document.getElementById('cyl-probe-status');
  document.getElementById('cyl-run-btn').disabled = true;
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();
  const probeResults = { east: [], west: [], north: [], south: [] };
  
  try {
    statusEl.innerHTML = '<div class="probe-status working">Starting probe sequence...</div>';
    await sendAndWait('G91');
    
    // EAST
    statusEl.innerHTML = '<div class="probe-status working">Probing East...</div>';
    await moveRel('X', probeDistance);
    await moveRel('Z', -probeDepth);
    probeResults.east.push(await probeAndCapture('X', -probeDistance * 2, feedrate));
    await moveRel('X', retract);
    probeResults.east.push(await probeAndCapture('X', -(retract + 5), feedrateSlow));
    await moveRel('X', retract);
    await moveRel('Z', probeDepth);
    
    // WEST
    statusEl.innerHTML = '<div class="probe-status working">Probing West...</div>';
    await moveRel('X', -(probeDistance * 2 + retract));
    await moveRel('Z', -probeDepth);
    probeResults.west.push(await probeAndCapture('X', probeDistance * 2, feedrate));
    await moveRel('X', -retract);
    probeResults.west.push(await probeAndCapture('X', retract + 5, feedrateSlow));
    
    const eastX = (probeResults.east[0].x + probeResults.east[1].x) / 2;
    const westX = (probeResults.west[0].x + probeResults.west[1].x) / 2;
    const centerX = (eastX + westX) / 2;
    console.log('X Center: ' + centerX.toFixed(3));
    
    await moveRel('X', -retract);
    await moveRel('Z', probeDepth);
    
    statusEl.innerHTML = '<div class="probe-status working">Moving to X center...</div>';
    await sendAndWait('G90');
    await sendAndWait('G53 G0 X' + centerX.toFixed(3));
    await sendAndWait('G91');
    
    // NORTH
    statusEl.innerHTML = '<div class="probe-status working">Probing North...</div>';
    await moveRel('Y', probeDistance);
    await moveRel('Z', -probeDepth);
    probeResults.north.push(await probeAndCapture('Y', -probeDistance * 2, feedrate));
    await moveRel('Y', retract);
    probeResults.north.push(await probeAndCapture('Y', -(retract + 5), feedrateSlow));
    await moveRel('Y', retract);
    await moveRel('Z', probeDepth);
    
    // SOUTH
    statusEl.innerHTML = '<div class="probe-status working">Probing South...</div>';
    await moveRel('Y', -(probeDistance * 2 + retract));
    await moveRel('Z', -probeDepth);
    probeResults.south.push(await probeAndCapture('Y', probeDistance * 2, feedrate));
    await moveRel('Y', -retract);
    probeResults.south.push(await probeAndCapture('Y', retract + 5, feedrateSlow));
    
    const northY = (probeResults.north[0].y + probeResults.north[1].y) / 2;
    const southY = (probeResults.south[0].y + probeResults.south[1].y) / 2;
    const centerY = (northY + southY) / 2;
    console.log('Y Center: ' + centerY.toFixed(3));
    
    await moveRel('Y', -retract);
    await moveRel('Z', probeDepth);
    
    statusEl.innerHTML = '<div class="probe-status working">Moving to center...</div>';
    await sendAndWait('G90');
    await sendAndWait('G53 G0 X' + centerX.toFixed(3) + ' Y' + centerY.toFixed(3));
    
    const result = calculateProbeResults(eastX, westX, northY, southY, tipDia);
    displayCylinderResults(result);
    statusEl.innerHTML = '<div class="probe-status ready">✓ Complete! At cylinder center.</div>';
    
  } catch (err) {
    console.error('Probe error:', err);
    statusEl.innerHTML = '<div class="probe-status error">✗ Failed: ' + err.message + '</div>';
    try { sendCommand('G91 G0 Z10'); sendCommand('G90'); } catch(e) {}
  } finally {
    sendCommand('G90');
    App.probeInProgress = false;
    document.getElementById('cyl-run-btn').disabled = false;
  }
}
//#endregion

//#region ===== HOLE PROBE =====
const HoleProbe = { result: null, history: [] };

function updateHoleProbeDistance() {
  const dia = parseFloat(document.getElementById('hole-diameter').value) || 20;
  document.getElementById('hole-probe-distance').value = (dia / 2 + 2).toFixed(1);
}

function updateHoleTipDiameter() {
  document.getElementById('hole-tip-dia').value = App.settings.probe.tipDiameter;
}

function loadHolePresets() {
  const sel = document.getElementById('hole-preset-select');
  sel.innerHTML = '<option value="">-- Select Preset --</option>';
  App.settings.presets.hole.forEach((p, i) => {
    sel.innerHTML += '<option value="' + i + '">' + (p.name || 'Preset ' + (i+1)) + '</option>';
  });
}

function loadHolePreset() {
  const idx = parseInt(document.getElementById('hole-preset-select').value);
  if (isNaN(idx)) return;
  const p = App.settings.presets.hole[idx];
  if (!p) return;
  document.getElementById('hole-preset-name').value = p.name || '';
  document.getElementById('hole-diameter').value = p.diameter || 20;
  document.getElementById('hole-probe-distance').value = p.probeDistance || 12;
  document.getElementById('hole-feedrate').value = p.feedrate || 100;
}

function saveHolePreset() {
  const name = document.getElementById('hole-preset-name').value.trim();
  if (!name) { alert('Enter a preset name'); return; }
  const preset = {
    name: name,
    diameter: parseFloat(document.getElementById('hole-diameter').value) || 20,
    probeDistance: parseFloat(document.getElementById('hole-probe-distance').value) || 12,
    feedrate: parseInt(document.getElementById('hole-feedrate').value) || 100
  };
  const idx = App.settings.presets.hole.findIndex(p => p.name === name);
  if (idx >= 0) App.settings.presets.hole[idx] = preset;
  else App.settings.presets.hole.push(preset);
  saveSettingsToEmbedded();
  updateSettingsJSON();
  loadHolePresets();
  updatePresetCounts();
  alert('Preset "' + name + '" saved!');
}

function deleteHolePreset() {
  const idx = parseInt(document.getElementById('hole-preset-select').value);
  if (isNaN(idx)) { alert('Select a preset to delete'); return; }
  const name = App.settings.presets.hole[idx].name;
  if (confirm('Delete preset "' + name + '"?')) {
    App.settings.presets.hole.splice(idx, 1);
    saveSettingsToEmbedded();
    updateSettingsJSON();
    loadHolePresets();
    updatePresetCounts();
  }
}

function setHoleZero(axis) {
  if (!HoleProbe.result || !App.isConnected) return;
  if (axis === 'XY') sendCommand('G10 L20 P1 X0 Y0');
  else sendCommand('G10 L20 P1 ' + axis + '0');
  setTimeout(() => { sendCommand('$#'); setTimeout(() => sendCommand('?'), 100); }, 100);
}

function toggleHoleRepeatability() {
  const en = document.getElementById('hole-repeatability-mode').checked;
  document.getElementById('hole-history-actions').style.display = en ? 'block' : 'none';
  if (en) { HoleProbe.history = []; updateHoleHistory(); }
}

function clearHoleHistory() {
  HoleProbe.history = [];
  updateHoleHistory();
}

function updateHoleHistory() {
  const el = document.getElementById('hole-history');
  if (HoleProbe.history.length === 0) {
    el.innerHTML = '<p class="text-muted">No runs recorded yet.</p>';
    return;
  }
  const avgX = HoleProbe.history.reduce((s, r) => s + r.centerX, 0) / HoleProbe.history.length;
  const avgY = HoleProbe.history.reduce((s, r) => s + r.centerY, 0) / HoleProbe.history.length;
  let html = '<table style="width:100%;font-size:12px;border-collapse:collapse;"><tr style="color:var(--text-secondary);"><th>Run</th><th>X</th><th>Y</th><th>ΔX</th><th>ΔY</th></tr>';
  HoleProbe.history.forEach((r, i) => {
    const dx = r.centerX - avgX, dy = r.centerY - avgY;
    html += '<tr><td>' + (i+1) + '</td><td>' + r.centerX.toFixed(3) + '</td><td>' + r.centerY.toFixed(3) + '</td><td>' + (dx>=0?'+':'') + dx.toFixed(3) + '</td><td>' + (dy>=0?'+':'') + dy.toFixed(3) + '</td></tr>';
  });
  html += '</table>';
  el.innerHTML = html;
}

function displayHoleResults(result) {
  HoleProbe.result = result;
  const el = document.getElementById('hole-results');
  const expDia = parseFloat(document.getElementById('hole-diameter').value) || 20;
  const dev = result.diameterAvg - expDia;
  el.innerHTML = '<div class="results-grid">' +
    '<span class="label">Center X:</span><span class="value">' + result.centerX.toFixed(3) + ' mm (MCS)</span>' +
    '<span class="label">Center Y:</span><span class="value">' + result.centerY.toFixed(3) + ' mm (MCS)</span>' +
    '<span class="label">Diameter X:</span><span class="value">' + result.diameterX.toFixed(3) + ' mm</span>' +
    '<span class="label">Diameter Y:</span><span class="value">' + result.diameterY.toFixed(3) + ' mm</span>' +
    '<span class="label">Avg Diameter:</span><span class="value">' + result.diameterAvg.toFixed(3) + ' mm</span>' +
    '<span class="label">Deviation:</span><span class="value">' + (dev>=0?'+':'') + dev.toFixed(3) + ' mm</span></div>';
  document.getElementById('hole-results-actions').style.display = 'flex';
  if (document.getElementById('hole-repeatability-mode').checked) {
    HoleProbe.history.push(result);
    updateHoleHistory();
  }
}

async function runHoleProbe() {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (App.probeInProgress) { alert('Probe already running'); return; }
  
  const probeDistance = parseFloat(document.getElementById('hole-probe-distance').value);
  const feedrate = parseInt(document.getElementById('hole-feedrate').value) || 100;
  const feedrateSlow = App.settings.probe.feedrateSlow || 50;
  const retract = App.settings.probe.retractDistance || 2;
  const tipDia = App.settings.probe.tipDiameter || 2;
  
  const diameter = document.getElementById('hole-diameter').value;
  if (!confirm('Hole Probe\n\nApprox diameter: ' + diameter + ' mm\nProbe distance: ' + probeDistance + ' mm\n\nProbe tip is INSIDE hole near center?\n\nContinue?')) return;
  
  App.probeInProgress = true;
  probeCommandId = 0;
  const statusEl = document.getElementById('hole-probe-status');
  document.getElementById('hole-run-btn').disabled = true;
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();
  const probeResults = { east: [], west: [], north: [], south: [] };
  
  try {
    statusEl.innerHTML = '<div class="probe-status working">Starting hole probe...</div>';
    await sendAndWait('G91');
    
    // HOLE PROBE: Start from inside, probe OUTWARD to walls
    // EAST (+X direction)
    statusEl.innerHTML = '<div class="probe-status working">Probing East wall...</div>';
    probeResults.east.push(await probeAndCapture('X', probeDistance, feedrate));
    await moveRel('X', -retract);
    probeResults.east.push(await probeAndCapture('X', retract + 3, feedrateSlow));
    const eastX = (probeResults.east[0].x + probeResults.east[1].x) / 2;

    // Retract and move to opposite side using absolute positioning
    await moveRel('X', -retract);
    await sendAndWait('G90');
    await sendAndWait('G53 G0 X' + (eastX - probeDistance).toFixed(3));  // Move to West side
    await sendAndWait('G91');

    // WEST (-X direction) - probe outward (West)
    statusEl.innerHTML = '<div class="probe-status working">Probing West wall...</div>';
    probeResults.west.push(await probeAndCapture('X', -probeDistance, feedrate));
    await moveRel('X', retract);
    probeResults.west.push(await probeAndCapture('X', -(retract + 3), feedrateSlow));
    const westX = (probeResults.west[0].x + probeResults.west[1].x) / 2;

    const centerX = (eastX + westX) / 2;
    console.log('X Center: ' + centerX.toFixed(3) + ' (East: ' + eastX.toFixed(3) + ', West: ' + westX.toFixed(3) + ')');

    // Move to X center
    statusEl.innerHTML = '<div class="probe-status working">Moving to X center...</div>';
    await sendAndWait('G90');
    await sendAndWait('G53 G0 X' + centerX.toFixed(3));
    await sendAndWait('G91');
    
    // NORTH (+Y direction)
    statusEl.innerHTML = '<div class="probe-status working">Probing North wall...</div>';
    probeResults.north.push(await probeAndCapture('Y', probeDistance, feedrate));
    await moveRel('Y', -retract);
    probeResults.north.push(await probeAndCapture('Y', retract + 3, feedrateSlow));
    const northY = (probeResults.north[0].y + probeResults.north[1].y) / 2;

    // Retract and move to opposite side using absolute positioning
    await moveRel('Y', -retract);
    await sendAndWait('G90');
    await sendAndWait('G53 G0 Y' + (northY - probeDistance).toFixed(3));  // Move to South side
    await sendAndWait('G91');

    // SOUTH (-Y direction) - probe outward (South)
    statusEl.innerHTML = '<div class="probe-status working">Probing South wall...</div>';
    probeResults.south.push(await probeAndCapture('Y', -probeDistance, feedrate));
    await moveRel('Y', retract);
    probeResults.south.push(await probeAndCapture('Y', -(retract + 3), feedrateSlow));
    const southY = (probeResults.south[0].y + probeResults.south[1].y) / 2;

    const centerY = (northY + southY) / 2;
    console.log('Y Center: ' + centerY.toFixed(3) + ' (North: ' + northY.toFixed(3) + ', South: ' + southY.toFixed(3) + ')');
    
    // Move to true center
    statusEl.innerHTML = '<div class="probe-status working">Moving to hole center...</div>';
    await sendAndWait('G90');
    await sendAndWait('G53 G0 X' + centerX.toFixed(3) + ' Y' + centerY.toFixed(3));
    
    const result = calculateHoleResults(eastX, westX, northY, southY, tipDia);
    displayHoleResults(result);
    statusEl.innerHTML = '<div class="probe-status ready">✓ Complete! At hole center.</div>';
    
  } catch (err) {
    console.error('Probe error:', err);
    statusEl.innerHTML = '<div class="probe-status error">✗ Failed: ' + err.message + '</div>';
    try { sendCommand('G90'); } catch(e) {}
  } finally {
    sendCommand('G90');
    App.probeInProgress = false;
    document.getElementById('hole-run-btn').disabled = false;
  }
}
//#endregion

//#region ===== CORNER PROBE =====
const CornerProbe = { result: null };

function loadCornerPresets() {
  const sel = document.getElementById('corner-preset-select');
  sel.innerHTML = '<option value="">-- Select Preset --</option>';
  App.settings.presets.corner.forEach((p, i) => {
    sel.innerHTML += '<option value="' + i + '">' + (p.name || 'Preset ' + (i+1)) + '</option>';
  });
}

function loadCornerPreset() {
  const idx = parseInt(document.getElementById('corner-preset-select').value);
  if (isNaN(idx)) return;
  const p = App.settings.presets.corner[idx];
  if (!p) return;
  document.getElementById('corner-preset-name').value = p.name || '';
  document.getElementById('corner-location').value = p.cornerLocation || 'SW';
  document.getElementById('corner-type').value = p.cornerType || 'outside';
  document.getElementById('corner-start-dist').value = p.startDistance || 5;
  document.getElementById('corner-travel-dist').value = p.travelDistance || 10;
  document.getElementById('corner-feedrate').value = p.feedrate || 100;
  document.getElementById('corner-move-to-corner').checked = p.moveToCorner !== false;
  document.getElementById('corner-z-safe').value = p.zSafe || 10;
}

function saveCornerPreset() {
  const name = document.getElementById('corner-preset-name').value.trim();
  if (!name) { alert('Enter a preset name'); return; }
  const preset = {
    name: name,
    cornerLocation: document.getElementById('corner-location').value,
    cornerType: document.getElementById('corner-type').value,
    startDistance: parseFloat(document.getElementById('corner-start-dist').value) || 5,
    travelDistance: parseFloat(document.getElementById('corner-travel-dist').value) || 10,
    feedrate: parseInt(document.getElementById('corner-feedrate').value) || 100,
    moveToCorner: document.getElementById('corner-move-to-corner').checked,
    zSafe: parseFloat(document.getElementById('corner-z-safe').value) || 10
  };
  const idx = App.settings.presets.corner.findIndex(p => p.name === name);
  if (idx >= 0) App.settings.presets.corner[idx] = preset;
  else App.settings.presets.corner.push(preset);
  saveSettingsToEmbedded();
  updateSettingsJSON();
  loadCornerPresets();
  updatePresetCounts();
  alert('Preset "' + name + '" saved!');
}

function deleteCornerPreset() {
  const idx = parseInt(document.getElementById('corner-preset-select').value);
  if (isNaN(idx)) { alert('Select a preset to delete'); return; }
  const name = App.settings.presets.corner[idx].name;
  if (confirm('Delete preset "' + name + '"?')) {
    App.settings.presets.corner.splice(idx, 1);
    saveSettingsToEmbedded();
    updateSettingsJSON();
    loadCornerPresets();
    updatePresetCounts();
  }
}

function setCornerZero(axis) {
  if (!CornerProbe.result || !App.isConnected) return;
  if (axis === 'XY') sendCommand('G10 L20 P1 X0 Y0');
  else sendCommand('G10 L20 P1 ' + axis + '0');
  setTimeout(() => { sendCommand('$#'); setTimeout(() => sendCommand('?'), 100); }, 100);
}

function displayCornerResults(result) {
  CornerProbe.result = result;
  const el = document.getElementById('corner-results');
  el.innerHTML = '<div class="results-grid">' +
    '<span class="label">Corner X:</span><span class="value">' + result.cornerX.toFixed(3) + ' mm (MCS)</span>' +
    '<span class="label">Corner Y:</span><span class="value">' + result.cornerY.toFixed(3) + ' mm (MCS)</span>' +
    '<span class="label">Edge 1 (X):</span><span class="value">' + result.edge1.toFixed(3) + ' mm</span>' +
    '<span class="label">Edge 2 (Y):</span><span class="value">' + result.edge2.toFixed(3) + ' mm</span></div>';
  document.getElementById('corner-results-actions').style.display = 'flex';
}

async function runCornerProbe() {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (App.probeInProgress) { alert('Probe already running'); return; }

  // Get settings from UI
  const cornerLoc = document.getElementById('corner-location').value; // SW, SE, NW, NE
  const cornerType = document.getElementById('corner-type').value; // outside or inside
  const startDist = parseFloat(document.getElementById('corner-start-dist').value);
  const travelDist = parseFloat(document.getElementById('corner-travel-dist').value);
  const feedrate = parseInt(document.getElementById('corner-feedrate').value) || 100;
  const feedrateSlow = App.settings.probe.feedrateSlow || 50;
  const retract = App.settings.probe.retractDistance || 2;
  const tipDia = App.settings.probe.tipDiameter || 2;
  const moveToCorner = document.getElementById('corner-move-to-corner').checked;
  const zSafe = parseFloat(document.getElementById('corner-z-safe').value);

  // Sanity check
  if (travelDist < startDist) {
    alert('Warning: Travel distance should be at least equal to start distance!');
    return;
  }

  // Define probe directions based on corner location (SW, SE, NW, NE)
  // Format: first probe direction, second probe direction
  const cornerDefs = {
    'SW': { probe1: '+X', probe2: '+Y', desc: 'Southwest (Bottom-Left)' },
    'SE': { probe1: '-X', probe2: '+Y', desc: 'Southeast (Bottom-Right)' },
    'NW': { probe1: '+X', probe2: '-Y', desc: 'Northwest (Top-Left)' },
    'NE': { probe1: '-X', probe2: '-Y', desc: 'Northeast (Top-Right)' }
  };

  const corner = cornerDefs[cornerLoc];
  if (!corner) { alert('Invalid corner location'); return; }

  if (!confirm(`Corner Probe\n\nLocation: ${corner.desc}\nType: ${cornerType}\nStart Distance: ${startDist}mm\nTravel Distance: ${travelDist}mm\n\nProbe positioned at (A), ${startDist}mm from each wall?\nZ at correct height?\n\nContinue?`)) return;

  App.probeInProgress = true;
  probeCommandId = 0;
  const statusEl = document.getElementById('corner-probe-status');
  document.getElementById('corner-run-btn').disabled = true;
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();

  try {
    statusEl.innerHTML = '<div class="probe-status working">Starting corner probe...</div>';
    await sendAndWait('G91');

    // STEP 7: Probe first wall (direction 1)
    statusEl.innerHTML = '<div class="probe-status working">Probing first wall...</div>';
    const axis1 = corner.probe1.charAt(1); // 'X' or 'Y'
    const dir1 = corner.probe1.charAt(0) === '+' ? 1 : -1;

    const probe1a = await probeAndCapture(axis1, dir1 * startDist, feedrate);
    await moveRel(axis1, -dir1 * retract);
    const probe1b = await probeAndCapture(axis1, dir1 * (retract + 3), feedrateSlow);
    const wall1Pos = (probe1a[axis1.toLowerCase()] + probe1b[axis1.toLowerCase()]) / 2;
    console.log(`Wall 1 (${axis1}): ${wall1Pos.toFixed(3)}`);

    // Return to position (A)
    await moveRel(axis1, -dir1 * retract);

    // STEP 8: Move from (A) to (B) - perpendicular to first wall, AWAY from second wall
    statusEl.innerHTML = '<div class="probe-status working">Moving to position (B)...</div>';
    const axis2 = corner.probe2.charAt(1); // 'X' or 'Y'
    const dir2 = corner.probe2.charAt(0) === '+' ? 1 : -1;
    await moveRel(axis2, -dir2 * travelDist);  // Move OPPOSITE of probe direction

    // STEP 9: Move from (B) to (C) - past first wall by startDist
    statusEl.innerHTML = '<div class="probe-status working">Moving to position (C)...</div>';
    await moveRel(axis1, dir1 * (startDist * 2));

    // STEP 10: Probe second wall (direction 4)
    statusEl.innerHTML = '<div class="probe-status working">Probing second wall...</div>';
    const probe2a = await probeAndCapture(axis2, dir2 * (travelDist + startDist), feedrate);
    await moveRel(axis2, -dir2 * retract);
    const probe2b = await probeAndCapture(axis2, dir2 * (retract + 3), feedrateSlow);
    const wall2Pos = (probe2a[axis2.toLowerCase()] + probe2b[axis2.toLowerCase()]) / 2;
    console.log(`Wall 2 (${axis2}): ${wall2Pos.toFixed(3)}`);

    // Return to position (C)
    await moveRel(axis2, -dir2 * retract);

    // Calculate corner position (accounting for probe tip diameter)
    // For outside corner, the corner is tipDia/2 further in each direction
    const cornerPos = {};
    cornerPos[axis1.toLowerCase()] = wall1Pos + dir1 * (tipDia / 2);
    cornerPos[axis2.toLowerCase()] = wall2Pos + dir2 * (tipDia / 2);

    // STEP 11: Optionally move to corner (leave Z at safe height for tool change)
    if (moveToCorner) {
      statusEl.innerHTML = '<div class="probe-status working">Moving to corner at safe Z height...</div>';
      // Raise Z to safe height (relative)
      await moveRel('Z', zSafe);
      // Move to corner XY (absolute machine coordinates)
      await sendAndWait('G90');
      await sendAndWait(`G53 G0 X${cornerPos.x.toFixed(3)} Y${cornerPos.y.toFixed(3)}`);
      // Stay at safe Z height - ready for tool change and manual Z zero setting
    }

    await sendAndWait('G90');

    const result = {
      cornerX: cornerPos.x,
      cornerY: cornerPos.y,
      edge1: wall1Pos,
      edge2: wall2Pos
    };
    displayCornerResults(result);
    statusEl.innerHTML = '<div class="probe-status ready">✓ Complete! Walls measured.</div>';

  } catch (err) {
    console.error('Probe error:', err);
    statusEl.innerHTML = '<div class="probe-status error">✗ Failed: ' + err.message + '</div>';
    try { sendCommand('G90'); } catch(e) {}
  } finally {
    sendCommand('G90');
    App.probeInProgress = false;
    document.getElementById('corner-run-btn').disabled = false;
  }
}

//#region ===== SIDE PROBE =====
const SideProbe = {
  point1: null,  // { x, y, z, measured: number }
  point2: null,
  direction: null,  // '+X', '-X', '+Y', '-Y'
  lastDifference: null,  // Track previous difference for comparison
  lastProbeTime: null  // Timestamp of last probe
};

function updateSideProbeButtons() {
  const hasPoint1 = SideProbe.point1 !== null;
  const hasPoint2 = SideProbe.point2 !== null;

  const btnPoint1 = document.getElementById('btn-side-set-point1');
  const btnPoint2 = document.getElementById('btn-side-set-point2');
  const btnReprobe = document.getElementById('btn-side-reprobe-point2');
  const btnBoth = document.getElementById('btn-side-probe-both');
  const btnClear = document.getElementById('btn-side-clear');

  // Fresh start: Point 1 is the next action
  if (!hasPoint1) {
    btnPoint1.disabled = false;
    btnPoint1.classList.add('btn-primary'); // Highlighted
    btnPoint2.disabled = true;
    btnPoint2.classList.remove('btn-primary');
    btnReprobe.disabled = true;
    btnReprobe.classList.remove('btn-primary');
    btnBoth.disabled = true;
    btnBoth.classList.remove('btn-primary');
    btnClear.disabled = true;
  }
  // Point 1 set: Point 2 is the next action
  else if (!hasPoint2) {
    btnPoint1.disabled = false;
    btnPoint1.classList.remove('btn-primary'); // De-emphasized
    btnPoint2.disabled = false;
    btnPoint2.classList.add('btn-primary'); // Highlighted
    btnReprobe.disabled = true;
    btnReprobe.classList.remove('btn-primary');
    btnBoth.disabled = true;
    btnBoth.classList.remove('btn-primary');
    btnClear.disabled = false;
  }
  // Both points set: Re-Probe and Probe Both are next actions
  else {
    btnPoint1.disabled = false;
    btnPoint1.classList.remove('btn-primary'); // De-emphasized
    btnPoint2.disabled = false;
    btnPoint2.classList.remove('btn-primary'); // De-emphasized
    btnReprobe.disabled = false;
    btnReprobe.classList.add('btn-primary'); // Highlighted
    btnBoth.disabled = false;
    btnBoth.classList.add('btn-primary'); // Highlighted
    btnClear.disabled = false;
  }
}

function clearSidePoints() {
  SideProbe.point1 = null;
  SideProbe.point2 = null;
  SideProbe.direction = null;
  SideProbe.lastDifference = null;
  SideProbe.lastProbeTime = null;

  document.getElementById('side-point1-status').textContent = 'Not Set';
  document.getElementById('side-point1-status').style.color = '#999';
  document.getElementById('side-point1-coords').textContent = '';

  document.getElementById('side-point2-status').textContent = 'Not Set';
  document.getElementById('side-point2-status').style.color = '#999';
  document.getElementById('side-point2-coords').textContent = '';

  document.getElementById('side-results').textContent = 'Ready to probe. Manually jog to first point and click "Set Point 1 & Probe".';

  updateSideProbeButtons();
}

async function setSidePoint1AndProbe() {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (App.probeInProgress) { alert('Probe already running'); return; }

  const direction = document.getElementById('side-probe-direction').value; // '+X', '-X', '+Y', '-Y'
  const probeDistance = parseFloat(document.getElementById('side-probe-distance').value);
  const feedrate = parseInt(document.getElementById('side-probe-feedrate').value);
  const feedrateSlow = parseInt(document.getElementById('side-probe-feedrate-slow').value);
  const retract = App.settings.probe.retractDistance || 2;

  if (!confirm(`Set Point 1 & Probe\n\nDirection: ${direction}\nProbe Distance: ${probeDistance}mm\n\nProbe positioned approximately ${probeDistance}mm from edge?\nContinue?`)) return;

  App.probeInProgress = true;
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();

  try {
    // Get current position
    await sendAndWait('?');
    await new Promise(resolve => setTimeout(resolve, 100));
    const currentPos = { x: App.position.mcs.x, y: App.position.mcs.y, z: App.position.mcs.z };

    // Perform double-probe sequence
    await sendAndWait('G91');
    const axis = direction.charAt(1); // 'X' or 'Y'
    const dir = direction.charAt(0) === '+' ? 1 : -1;

    const probe1 = await probeAndCapture(axis, dir * probeDistance, feedrate);
    await moveRel(axis, -dir * retract); // Retract
    const probe2 = await probeAndCapture(axis, dir * (retract + 3), feedrateSlow); // Slow probe
    const measured = (probe1[axis.toLowerCase()] + probe2[axis.toLowerCase()]) / 2;
    await moveRel(axis, -dir * retract); // Return to original position
    await sendAndWait('G90');

    // Store Point 1
    SideProbe.point1 = {
      x: currentPos.x,
      y: currentPos.y,
      z: currentPos.z,
      measured: measured
    };
    SideProbe.direction = direction;

    // Update UI
    document.getElementById('side-point1-status').textContent = `Set (${direction})`;
    document.getElementById('side-point1-status').style.color = '#4CAF50';
    document.getElementById('side-point1-coords').textContent = `MCS: X${currentPos.x.toFixed(3)} Y${currentPos.y.toFixed(3)} Z${currentPos.z.toFixed(3)}`;

    document.getElementById('side-results').textContent =
      `Point 1 Set:\nPosition: X${currentPos.x.toFixed(3)} Y${currentPos.y.toFixed(3)}\nMeasured (${axis}): ${measured.toFixed(3)} mm\n\nManually jog to Point 2 and click "Set Point 2 & Probe".`;

    updateSideProbeButtons();

  } catch (err) {
    console.error('Probe error:', err);
    alert('Probe failed: ' + err.message);
    try { sendCommand('G90'); } catch(e) {}
  } finally {
    sendCommand('G90');
    App.probeInProgress = false;
  }
}

async function setSidePoint2AndProbe() {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (App.probeInProgress) { alert('Probe already running'); return; }
  if (!SideProbe.point1) { alert('Point 1 not set'); return; }

  const direction = SideProbe.direction;
  const probeDistance = parseFloat(document.getElementById('side-probe-distance').value);
  const feedrate = parseInt(document.getElementById('side-probe-feedrate').value);
  const feedrateSlow = parseInt(document.getElementById('side-probe-feedrate-slow').value);
  const retract = App.settings.probe.retractDistance || 2;

  // Get current position for sanity check - must use sendAndWait to ensure position is updated
  const { sendAndWait: sendAndWaitTemp } = createProbeHelpers();
  await sendAndWaitTemp('?');
  await new Promise(resolve => setTimeout(resolve, 200)); // Extra time for position update
  const currentPos = { x: App.position.mcs.x, y: App.position.mcs.y, z: App.position.mcs.z };

  // Sanity check: user should move along the perpendicular axis, not the probe direction
  const probeAxis = direction.charAt(1); // 'X' or 'Y' - the axis we're probing toward
  const travelAxis = probeAxis === 'X' ? 'Y' : 'X'; // The axis we should move along
  const probeAxisDiff = Math.abs(currentPos[probeAxis.toLowerCase()] - SideProbe.point1[probeAxis.toLowerCase()]);
  const travelAxisDiff = Math.abs(currentPos[travelAxis.toLowerCase()] - SideProbe.point1[travelAxis.toLowerCase()]);

  // Check that we moved at least 5mm along the travel axis (perpendicular to probe direction)
  if (travelAxisDiff < 5) {
    alert(`Warning: Point 2 must be at least 5mm away from Point 1 along ${travelAxis} axis.\nCurrent distance: ${travelAxisDiff.toFixed(2)}mm\n\n(You should move along ${travelAxis}, not ${probeAxis})`);
    return;
  }

  // Warn if probe axis changed too much (should stay roughly same distance from edge)
  if (probeAxisDiff > 1) {
    if (!confirm(`Warning: ${probeAxis} axis has changed by ${probeAxisDiff.toFixed(2)}mm.\nFor accurate alignment measurement, you should only move along ${travelAxis} axis.\nContinue anyway?`)) {
      return;
    }
  }

  if (!confirm(`Set Point 2 & Probe\n\nDirection: ${direction}\nProbe Distance: ${probeDistance}mm\n\nProbe positioned approximately ${probeDistance}mm from edge?\nContinue?`)) return;

  App.probeInProgress = true;
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();

  try {
    // Perform double-probe sequence
    await sendAndWait('G91');
    const axis = probeAxis; // Use probeAxis from sanity check above
    const dir = direction.charAt(0) === '+' ? 1 : -1;

    const probe1 = await probeAndCapture(axis, dir * probeDistance, feedrate);
    await moveRel(axis, -dir * retract); // Retract
    const probe2 = await probeAndCapture(axis, dir * (retract + 3), feedrateSlow); // Slow probe
    const measured = (probe1[axis.toLowerCase()] + probe2[axis.toLowerCase()]) / 2;
    await moveRel(axis, -dir * retract); // Return to original position
    await sendAndWait('G90');

    // Store Point 2
    SideProbe.point2 = {
      x: currentPos.x,
      y: currentPos.y,
      z: currentPos.z,
      measured: measured
    };

    // Update UI
    document.getElementById('side-point2-status').textContent = `Set (${direction})`;
    document.getElementById('side-point2-status').style.color = '#4CAF50';
    document.getElementById('side-point2-coords').textContent = `MCS: X${currentPos.x.toFixed(3)} Y${currentPos.y.toFixed(3)} Z${currentPos.z.toFixed(3)}`;

    // Calculate and display results
    displaySideProbeResults();

    updateSideProbeButtons();

  } catch (err) {
    console.error('Probe error:', err);
    alert('Probe failed: ' + err.message);
    try { sendCommand('G90'); } catch(e) {}
  } finally {
    sendCommand('G90');
    App.probeInProgress = false;
  }
}

async function reprobeSidePoint2() {
  // Same as setSidePoint2AndProbe but keeps existing Point 2 position
  await setSidePoint2AndProbe();
}

async function probeBothSidePoints() {
  if (!App.isConnected) { alert('Not connected'); return; }
  if (App.probeInProgress) { alert('Probe already running'); return; }
  if (!SideProbe.point1 || !SideProbe.point2) { alert('Both points must be set first'); return; }

  const direction = SideProbe.direction;
  const probeDistance = parseFloat(document.getElementById('side-probe-distance').value);
  const feedrate = parseInt(document.getElementById('side-probe-feedrate').value);
  const feedrateSlow = parseInt(document.getElementById('side-probe-feedrate-slow').value);
  const retract = App.settings.probe.retractDistance || 2;
  const raiseZ = document.getElementById('side-raise-z').checked;
  const zSafe = parseFloat(document.getElementById('side-z-safe').value);

  if (!confirm(`Probe Both Points\n\nThis will automatically move to Point 1, probe, then move to Point 2 and probe.\n\nDirection: ${direction}\nProbe Distance: ${probeDistance}mm\nRaise Z: ${raiseZ ? 'Yes (' + zSafe + 'mm)' : 'No'}\n\nContinue?`)) return;

  App.probeInProgress = true;
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();

  try {
    const axis = direction.charAt(1); // 'X' or 'Y'
    const dir = direction.charAt(0) === '+' ? 1 : -1;

    // Move to Point 1 (with optional Z raise for safety)
    if (raiseZ) {
      // Raise Z to safe height (relative)
      await sendAndWait('G91');
      await moveRel('Z', zSafe);
      await sendAndWait('G90');
      // Move XY to Point 1
      await sendAndWait(`G53 G0 X${SideProbe.point1.x.toFixed(3)} Y${SideProbe.point1.y.toFixed(3)}`);
      // Lower Z back down (relative)
      await sendAndWait('G91');
      await moveRel('Z', -zSafe);
      await sendAndWait('G90');
    } else {
      // Direct move to Point 1 (XYZ together)
      await sendAndWait('G90');
      await sendAndWait(`G53 G0 X${SideProbe.point1.x.toFixed(3)} Y${SideProbe.point1.y.toFixed(3)} Z${SideProbe.point1.z.toFixed(3)}`);
    }
    await new Promise(resolve => setTimeout(resolve, 200));

    // Probe Point 1
    await sendAndWait('G91');
    const probe1a = await probeAndCapture(axis, dir * probeDistance, feedrate);
    await moveRel(axis, -dir * retract);
    const probe1b = await probeAndCapture(axis, dir * (retract + 3), feedrateSlow);
    const measured1 = (probe1a[axis.toLowerCase()] + probe1b[axis.toLowerCase()]) / 2;
    await moveRel(axis, -dir * retract); // Return to original position
    SideProbe.point1.measured = measured1;

    // Move to Point 2 (with optional Z raise for safety)
    if (raiseZ) {
      // Raise Z to safe height (relative)
      await sendAndWait('G91');
      await moveRel('Z', zSafe);
      await sendAndWait('G90');
      // Move XY to Point 2
      await sendAndWait(`G53 G0 X${SideProbe.point2.x.toFixed(3)} Y${SideProbe.point2.y.toFixed(3)}`);
      // Lower Z back down (relative)
      await sendAndWait('G91');
      await moveRel('Z', -zSafe);
      await sendAndWait('G90');
    } else {
      // Direct move to Point 2 (XYZ together)
      await sendAndWait('G90');
      await sendAndWait(`G53 G0 X${SideProbe.point2.x.toFixed(3)} Y${SideProbe.point2.y.toFixed(3)} Z${SideProbe.point2.z.toFixed(3)}`);
    }
    await new Promise(resolve => setTimeout(resolve, 200));

    // Probe Point 2
    await sendAndWait('G91');
    const probe2a = await probeAndCapture(axis, dir * probeDistance, feedrate);
    await moveRel(axis, -dir * retract);
    const probe2b = await probeAndCapture(axis, dir * (retract + 3), feedrateSlow);
    const measured2 = (probe2a[axis.toLowerCase()] + probe2b[axis.toLowerCase()]) / 2;
    await moveRel(axis, -dir * retract); // Return to original position
    SideProbe.point2.measured = measured2;

    await sendAndWait('G90');

    // Display results
    displaySideProbeResults();

  } catch (err) {
    console.error('Probe error:', err);
    alert('Probe failed: ' + err.message);
    try { sendCommand('G90'); } catch(e) {}
  } finally {
    sendCommand('G90');
    App.probeInProgress = false;
  }
}

function displaySideProbeResults() {
  if (!SideProbe.point1 || !SideProbe.point2) return;

  const probeAxis = SideProbe.direction.charAt(1); // X or Y - axis being probed
  const direction = SideProbe.direction; // Full direction like '+X', '-Y'
  const measured1 = SideProbe.point1.measured;
  const measured2 = SideProbe.point2.measured;
  const difference = measured2 - measured1;

  // Calculate the travel axis distance
  const travelAxis = probeAxis === 'X' ? 'Y' : 'X';
  const travelDistance = Math.abs(SideProbe.point2[travelAxis.toLowerCase()] - SideProbe.point1[travelAxis.toLowerCase()]);

  // Determine which point is further from edge (Point 1 or Point 2)
  const point1Further = measured1 > measured2;

  // Get timestamp
  const now = new Date();
  const timeStr = now.toLocaleTimeString();
  SideProbe.lastProbeTime = timeStr;

  let resultsText = `Side Probe Results - ${timeStr}\n\n`;
  resultsText += `Point 1 (Reference): ${measured1.toFixed(3)} mm from edge\n`;
  resultsText += `Point 2 (Adjust):    ${measured2.toFixed(3)} mm from edge\n`;
  resultsText += `Difference: ${Math.abs(difference).toFixed(3)} mm\n`;

  // Show comparison to last probe if available
  if (SideProbe.lastDifference !== null) {
    const change = Math.abs(difference) - SideProbe.lastDifference;
    if (change < -0.001) {
      resultsText += `Last Probe Difference: ${SideProbe.lastDifference.toFixed(3)} mm (✓ BETTER by ${Math.abs(change).toFixed(3)}mm)\n`;
    } else if (change > 0.001) {
      resultsText += `Last Probe Difference: ${SideProbe.lastDifference.toFixed(3)} mm (⚠ WORSE by ${change.toFixed(3)}mm)\n`;
    } else {
      resultsText += `Last Probe Difference: ${SideProbe.lastDifference.toFixed(3)} mm (= SAME)\n`;
    }
  }

  resultsText += `Travel Distance (${travelAxis}): ${travelDistance.toFixed(1)} mm\n\n`;

  // Store current difference for next comparison
  SideProbe.lastDifference = Math.abs(difference);

  if (Math.abs(difference) < 0.01) {
    resultsText += `✓ ALIGNED - Workpiece is parallel (within 0.01mm tolerance)`;
  } else {
    resultsText += `⚠ NOT PARALLEL - Adjust Point 2 to match Point 1:\n\n`;

    // Always frame as adjusting Point 2 to match Point 1 (reference)
    if (point1Further) {
      resultsText += `Point 2 is ${Math.abs(difference).toFixed(2)}mm CLOSER to edge than Point 1.\n`;
      resultsText += `Move Point 2 location AWAY from edge by ${Math.abs(difference).toFixed(2)}mm.\n`;
    } else {
      resultsText += `Point 2 is ${Math.abs(difference).toFixed(2)}mm FURTHER from edge than Point 1.\n`;
      resultsText += `Move Point 2 location CLOSER to edge by ${Math.abs(difference).toFixed(2)}mm.\n`;
    }

    resultsText += `\n(Point 1 = reference, do not move if possible)`;
  }

  document.getElementById('side-results').textContent = resultsText;
}
//#endregion

//#region ===== HEIGHT MAP =====
const HeightMap = {
  probeData: [],  // Array of {x, y, z, success}
  isProbing: false,
  abortRequested: false,
  slotX: [],
  yPos: [],
  currentSlot: 0,
  currentY: 0,
  totalPoints: 0,
  completedPoints: 0
};

function parseCSV(str) {
  return str.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
}

function saveHeightmapPreset() {
  const name = document.getElementById('hm-preset-name').value.trim();
  if (!name) {
    alert('Please enter a preset name');
    return;
  }

  const preset = {
    name: name,
    slotX: document.getElementById('hm-slot-x').value,
    yPos: document.getElementById('hm-y-pos').value,
    probeDepth: parseFloat(document.getElementById('hm-probe-depth').value),
    feedrate: parseInt(document.getElementById('hm-feedrate').value),
    timeout: parseInt(document.getElementById('hm-timeout').value)
  };

  if (!App.settings.presets.heightmap) {
    App.settings.presets.heightmap = [];
  }

  // Check if preset name already exists
  const existingIndex = App.settings.presets.heightmap.findIndex(p => p.name === name);
  if (existingIndex >= 0) {
    if (!confirm(`Preset "${name}" already exists. Overwrite?`)) return;
    App.settings.presets.heightmap[existingIndex] = preset;
  } else {
    App.settings.presets.heightmap.push(preset);
  }

  saveSettingsToEmbedded();
  updateSettingsJSON();
  loadHeightmapPresets();
  updatePresetCounts();
  document.getElementById('hm-preset-name').value = '';
  alert(`Preset "${name}" saved!`);
}

function loadHeightmapPresets() {
  const select = document.getElementById('hm-preset-list');
  select.innerHTML = '<option value="">-- Load Preset --</option>';
  if (!App.settings.presets.heightmap) return;
  App.settings.presets.heightmap.forEach((p, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = p.name;
    select.appendChild(opt);
  });
}

function loadHeightmapPreset() {
  const select = document.getElementById('hm-preset-list');
  const idx = parseInt(select.value);
  if (isNaN(idx)) return;

  const preset = App.settings.presets.heightmap[idx];
  if (!preset) return;

  document.getElementById('hm-slot-x').value = preset.slotX;
  document.getElementById('hm-y-pos').value = preset.yPos;
  document.getElementById('hm-probe-depth').value = preset.probeDepth;
  document.getElementById('hm-feedrate').value = preset.feedrate;
  document.getElementById('hm-timeout').value = preset.timeout;
  document.getElementById('hm-preset-name').value = preset.name;
}

function deleteHeightmapPreset() {
  const select = document.getElementById('hm-preset-list');
  const idx = parseInt(select.value);
  if (isNaN(idx)) {
    alert('Please select a preset to delete');
    return;
  }

  const preset = App.settings.presets.heightmap[idx];
  if (!confirm(`Delete preset "${preset.name}"?`)) return;

  App.settings.presets.heightmap.splice(idx, 1);
  saveSettingsToEmbedded();
  updateSettingsJSON();
  loadHeightmapPresets();
  updatePresetCounts();
}

async function setHeightmapStartPoint() {
  if (!App.isConnected) {
    alert('Not connected to FluidNC');
    return;
  }

  if (!confirm('Set current position as X0 Y0 in work coordinate system (G10 L20 P1 X0 Y0)?')) return;

  const { sendAndWait } = createProbeHelpers();

  try {
    await sendAndWait('G10 L20 P1 X0 Y0');
    await sendAndWait('$#');  // Request WCO update
    alert('Start point set! Current position is now X0 Y0.');
  } catch (e) {
    alert('Failed to set start point: ' + e.message);
  }
}

async function startHeightmapProbe() {
  if (!App.isConnected) {
    alert('Not connected to FluidNC');
    return;
  }

  if (App.probeInProgress || HeightMap.isProbing) {
    alert('Probe already in progress');
    return;
  }

  // Create probe helpers
  const { sendAndWait, probeAndCapture, moveRel } = createProbeHelpers();

  // Parse configuration
  HeightMap.slotX = parseCSV(document.getElementById('hm-slot-x').value);
  HeightMap.yPos = parseCSV(document.getElementById('hm-y-pos').value);

  if (HeightMap.slotX.length === 0 || HeightMap.yPos.length === 0) {
    alert('Invalid slot X or Y positions');
    return;
  }

  const probeDepth = parseFloat(document.getElementById('hm-probe-depth').value);
  const feedrate = parseInt(document.getElementById('hm-feedrate').value);
  const timeout = parseInt(document.getElementById('hm-timeout').value) * 1000;

  if (probeDepth >= 0) {
    alert('Probe Depth must be negative');
    return;
  }

  HeightMap.totalPoints = HeightMap.slotX.length * HeightMap.yPos.length;
  if (!confirm(`Start probing ${HeightMap.totalPoints} points (${HeightMap.slotX.length} slots × ${HeightMap.yPos.length} Y positions)?`)) {
    return;
  }

  // Initialize probing state
  HeightMap.probeData = [];
  HeightMap.isProbing = true;
  HeightMap.abortRequested = false;
  HeightMap.currentSlot = 0;
  HeightMap.currentY = 0;
  HeightMap.completedPoints = 0;
  App.probeInProgress = true;

  document.getElementById('btn-hm-start').disabled = true;
  document.getElementById('btn-hm-abort').disabled = false;
  document.getElementById('btn-hm-export-csv').disabled = true;
  document.getElementById('btn-hm-export-html').disabled = true;
  document.getElementById('hm-results').textContent = 'Probing started...\n';

  try {
    // Initialize
    await sendAndWait('G21');  // Metric
    await sendAndWait('G90');  // Absolute positioning
    await sendAndWait('G54');  // Use WCS 1

    // Probe each slot
    for (let i = 0; i < HeightMap.slotX.length; i++) {
      if (HeightMap.abortRequested) break;

      HeightMap.currentSlot = i;
      const x = HeightMap.slotX[i];

      for (let j = 0; j < HeightMap.yPos.length; j++) {
        if (HeightMap.abortRequested) break;

        HeightMap.currentY = j;
        const y = HeightMap.yPos[j];

        updateHeightmapProgress();

        // Move XY to position (staying at Z=0)
        await sendAndWait(`G0 X${x.toFixed(3)} Y${y.toFixed(3)}`);

        // Probe down (use relative mode for probe)
        await sendAndWait('G91');  // Switch to relative
        const probeCmd = `G38.2 Z${probeDepth.toFixed(3)} F${feedrate}`;
        const response = await sendAndWait(probeCmd, timeout);
        await sendAndWait('G90');  // Back to absolute

        // Parse probe result
        console.log('Probe response:', response);
        const match = response.match(/\[PRB:([-\d.]+),([-\d.]+),([-\d.]+)(?:,[-\d.]+)?:(\d)\]/);
        console.log('Regex match:', match);

        if (match) {
          const px = parseFloat(match[1]);
          const py = parseFloat(match[2]);
          const pz = parseFloat(match[3]);
          const success = parseInt(match[4]) === 1;

          console.log(`Parsed: X=${px}, Y=${py}, Z=${pz}, success=${success}`);
          HeightMap.probeData.push({ x: px, y: py, z: pz, success });
          HeightMap.completedPoints++;
        } else {
          console.log('Probe failed - no match');
          // Probe failed
          HeightMap.probeData.push({ x: x, y: y, z: null, success: false });
          HeightMap.completedPoints++;
        }

        // Retract to Z=0
        await sendAndWait('G0 Z0');
      }
    }

    // Return to origin (already at Z=0)
    await sendAndWait('G0 X0 Y0');

    if (HeightMap.abortRequested) {
      document.getElementById('hm-results').textContent = 'Probing aborted by user.\n';
    } else {
      displayHeightmapResults();
      document.getElementById('btn-hm-export-csv').disabled = false;
      document.getElementById('btn-hm-export-html').disabled = false;
    }

  } catch (e) {
    document.getElementById('hm-results').textContent = 'Probing failed: ' + e.message;
    alert('Probing failed: ' + e.message);
  } finally {
    HeightMap.isProbing = false;
    App.probeInProgress = false;
    document.getElementById('btn-hm-start').disabled = false;
    document.getElementById('btn-hm-abort').disabled = true;
    document.getElementById('hm-progress').textContent = '';
  }
}

function abortHeightmapProbe() {
  if (HeightMap.isProbing) {
    HeightMap.abortRequested = true;
    document.getElementById('hm-progress').textContent = 'Aborting...';
  }
}

function updateHeightmapProgress() {
  const percent = ((HeightMap.completedPoints / HeightMap.totalPoints) * 100).toFixed(1);
  const slotNum = HeightMap.currentSlot + 1;
  const yNum = HeightMap.currentY + 1;
  document.getElementById('hm-progress').textContent =
    `Probing slot ${slotNum}/${HeightMap.slotX.length}, Y position ${yNum}/${HeightMap.yPos.length} (${percent}% complete)`;
}

function displayHeightmapResults() {
  const data = HeightMap.probeData.filter(d => d.success);
  if (data.length === 0) {
    document.getElementById('hm-results').textContent = 'No successful probe points.';
    return;
  }

  // Find reference Z (first point)
  const refZ = data[0].z;

  // Calculate statistics
  const zValues = data.map(d => d.z);
  const minZ = Math.min(...zValues);
  const maxZ = Math.max(...zValues);
  const avgZ = zValues.reduce((a, b) => a + b, 0) / zValues.length;
  const range = maxZ - minZ;

  // Build results text
  let resultsText = `Height Map Results (${data.length} points)\n\n`;
  resultsText += `Reference Z (first point): ${refZ.toFixed(3)} mm\n`;
  resultsText += `Min Z: ${minZ.toFixed(3)} mm\n`;
  resultsText += `Max Z: ${maxZ.toFixed(3)} mm\n`;
  resultsText += `Range: ${range.toFixed(3)} mm\n`;
  resultsText += `Average Z: ${avgZ.toFixed(3)} mm\n\n`;

  resultsText += `X Slots: ${HeightMap.slotX.join(', ')} mm\n`;
  resultsText += `Y Positions: ${HeightMap.yPos.join(', ')} mm\n\n`;

  resultsText += `Use Export buttons to save data as CSV or HTML report.`;

  document.getElementById('hm-results').textContent = resultsText;
}

function exportHeightmapCSV() {
  if (HeightMap.probeData.length === 0) {
    alert('No probe data to export');
    return;
  }

  let csv = 'X,Y,Z,Success,Deviation\n';
  const refZ = HeightMap.probeData.find(d => d.success)?.z || 0;

  HeightMap.probeData.forEach(d => {
    const dev = d.success ? (d.z - refZ).toFixed(3) : 'N/A';
    csv += `${d.x.toFixed(3)},${d.y.toFixed(3)},${d.z !== null ? d.z.toFixed(3) : 'N/A'},${d.success},${dev}\n`;
  });

  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `heightmap_${Date.now()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

function exportHeightmapHTML() {
  if (HeightMap.probeData.length === 0) {
    alert('No probe data to export');
    return;
  }

  const data = HeightMap.probeData.filter(d => d.success);
  const refZ = data[0].z;
  const zValues = data.map(d => d.z);
  const minZ = Math.min(...zValues);
  const maxZ = Math.max(...zValues);
  const avgZ = zValues.reduce((a, b) => a + b, 0) / zValues.length;
  const range = maxZ - minZ;

  // Build heatmap table
  let heatmapHTML = '<table border="1" cellpadding="4" style="border-collapse: collapse; font-size: 12px;">\n';
  heatmapHTML += '<tr><th>Y \\ X</th>';
  HeightMap.slotX.forEach(x => {
    heatmapHTML += `<th>${x.toFixed(1)}</th>`;
  });
  heatmapHTML += '</tr>\n';

  HeightMap.yPos.forEach(y => {
    heatmapHTML += `<tr><th>${y.toFixed(1)}</th>`;
    HeightMap.slotX.forEach(x => {
      const point = data.find(d => Math.abs(d.x - x) < 0.01 && Math.abs(d.y - y) < 0.01);
      if (point) {
        const dev = point.z - refZ;
        const absMax = Math.max(Math.abs(minZ - refZ), Math.abs(maxZ - refZ));
        const normalized = dev / (absMax || 1);  // -1 to 1

        // Color: blue (low) -> white (ref) -> red (high)
        let color;
        if (normalized < 0) {
          const intensity = Math.floor(255 * (1 + normalized));
          color = `rgb(${intensity},${intensity},255)`;
        } else {
          const intensity = Math.floor(255 * (1 - normalized));
          color = `rgb(255,${intensity},${intensity})`;
        }

        heatmapHTML += `<td style="background: ${color}; text-align: center;">${dev.toFixed(2)}</td>`;
      } else {
        heatmapHTML += '<td style="background: #ccc; text-align: center;">N/A</td>';
      }
    });
    heatmapHTML += '</tr>\n';
  });
  heatmapHTML += '</table>';

  // Build HTML report
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Height Map Report</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  table { border-collapse: collapse; margin: 20px 0; }
  th, td { border: 1px solid #999; padding: 6px; text-align: center; }
  th { background: #ddd; }
</style>
</head>
<body>
<h1>Height Map Report</h1>
<p>Generated: ${new Date().toLocaleString()}</p>

<h2>Summary Statistics</h2>
<table>
  <tr><th>Metric</th><th>Value</th></tr>
  <tr><td>Total Points</td><td>${data.length}</td></tr>
  <tr><td>Reference Z (first point)</td><td>${refZ.toFixed(3)} mm</td></tr>
  <tr><td>Min Z</td><td>${minZ.toFixed(3)} mm</td></tr>
  <tr><td>Max Z</td><td>${maxZ.toFixed(3)} mm</td></tr>
  <tr><td>Range</td><td>${range.toFixed(3)} mm</td></tr>
  <tr><td>Average Z</td><td>${avgZ.toFixed(3)} mm</td></tr>
</table>

<h2>Configuration</h2>
<p><strong>X Slots:</strong> ${HeightMap.slotX.join(', ')} mm</p>
<p><strong>Y Positions:</strong> ${HeightMap.yPos.join(', ')} mm</p>

<h2>Heatmap (Deviation from Reference)</h2>
${heatmapHTML}

<h2>Raw Data</h2>
<table>
  <tr><th>X</th><th>Y</th><th>Z</th><th>Deviation</th></tr>
${data.map(d => {
  const dev = d.z - refZ;
  return `  <tr><td>${d.x.toFixed(3)}</td><td>${d.y.toFixed(3)}</td><td>${d.z.toFixed(3)}</td><td>${dev.toFixed(3)}</td></tr>`;
}).join('\n')}
</table>
</body>
</html>`;

  // Download
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `heightmap_report_${Date.now()}.html`;
  a.click();
  URL.revokeObjectURL(url);
}
//#endregion

//#region ===== INITIALIZATION =====
function init() {
  console.log('FluidNC Probe Utility v' + VERSION);
  loadSettings();
  setupTabs();
  setupSettingsAutoSave();
  setupJogButtons();
  
  // Load presets for all probe types
  loadCylinderPresets();
  loadHolePresets();
  loadCornerPresets();
  loadHeightmapPresets();

  // Initialize Side Probe button states
  updateSideProbeButtons();

  // Update tip diameter displays
  document.getElementById('cyl-tip-dia').value = App.settings.probe.tipDiameter;
  document.getElementById('hole-tip-dia').value = App.settings.probe.tipDiameter;

  // Initialize probe distance calculations
  updateCylProbeDistance();
  updateHoleProbeDistance();
  
  // Button event listeners
  document.getElementById('connect-btn').addEventListener('click', connect);
  document.getElementById('disconnect-btn').addEventListener('click', disconnect);
  document.getElementById('stop-btn').addEventListener('click', emergencyStop);
  document.getElementById('refresh-json-btn').addEventListener('click', onRefreshJSON);
  document.getElementById('apply-json-btn').addEventListener('click', onApplyJSON);
  document.getElementById('format-json-btn').addEventListener('click', onFormatJSON);
  
  // Sync header IP/port with settings
  document.getElementById('ip-input').addEventListener('change', (e) => {
    document.getElementById('setting-ip').value = e.target.value;
    App.settings.connection.ip = e.target.value;
    saveSettingsToEmbedded();
    updateSettingsJSON();
  });
  document.getElementById('port-input').addEventListener('change', (e) => {
    document.getElementById('setting-port').value = e.target.value;
    App.settings.connection.port = parseInt(e.target.value);
    saveSettingsToEmbedded();
    updateSettingsJSON();
  });
  document.getElementById('setting-ip').addEventListener('change', (e) => {
    document.getElementById('ip-input').value = e.target.value;
  });
  document.getElementById('setting-port').addEventListener('change', (e) => {
    document.getElementById('port-input').value = e.target.value;
  });
  
  console.log('Initialization complete');
}

document.addEventListener('DOMContentLoaded', init);

window.addEventListener('beforeunload', (e) => {
  if (App.isConnected || App.probeInProgress) {
    e.preventDefault();
    e.returnValue = 'Connected to FluidNC or probe in progress. Leave anyway?';
    return e.returnValue;
  }
});
//#endregion
</script>
</body>
</html>
